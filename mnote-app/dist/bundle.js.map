{
  "version": 3,
  "sources": ["../../mnote-core/node_modules/mousetrap/mousetrap.js", "../../mnote-core/src/common/elbuilder.ts", "../../mnote-core/src/common/split.js", "../../mnote-core/src/modules/layout.ts", "../../mnote-core/src/modules/extensions.ts", "../../mnote-core/src/common/emitter.ts", "../../mnote-core/src/components/menu.ts", "../../mnote-core/src/common/util/dom.ts", "../../mnote-core/src/components/icons.ts", "../../mnote-core/src/modules/menubar.ts", "../../mnote-core/src/components/modal.ts", "../../mnote-core/src/common/util/path.ts", "../../mnote-core/src/common/strings.ts", "../../mnote-core/src/modules/editors.ts", "../../mnote-core/src/modules/fs.ts", "../../mnote-core/src/modules/logging.ts", "../../mnote-core/src/modules/ctxmenu.ts", "../../mnote-core/src/modules/system.ts", "../../mnote-core/src/modules/sidemenu.ts", "../../mnote-core/node_modules/preact/src/constants.js", "../../mnote-core/node_modules/preact/src/util.js", "../../mnote-core/node_modules/preact/src/options.js", "../../mnote-core/node_modules/preact/src/create-element.js", "../../mnote-core/node_modules/preact/src/component.js", "../../mnote-core/node_modules/preact/src/create-context.js", "../../mnote-core/node_modules/preact/src/diff/children.js", "../../mnote-core/node_modules/preact/src/diff/props.js", "../../mnote-core/node_modules/preact/src/diff/index.js", "../../mnote-core/node_modules/preact/src/render.js", "../../mnote-core/node_modules/preact/src/clone-element.js", "../../mnote-core/node_modules/preact/src/diff/catch-error.js", "../../mnote-core/src/components/icons-jsx.tsx", "../../mnote-core/src/components/filetree.tsx", "../../mnote-core/src/modules/filetree.tsx", "../../mnote-core/src/modules/settings.ts", "../../mnote-core/src/components/colors.ts", "../../mnote-core/src/modules/themes.ts", "../../mnote-core/src/modules/input.ts", "../../mnote-core/src/extensions/plaintextEditor.ts", "../../mnote-core/src/extensions/settingsEditor.ts", "../../mnote-core/src/mnote.ts", "../src-web/fs.ts", "../src-web/index.ts"],
  "sourcesContent": ["/*global define:false */\n/**\n * Copyright 2012-2017 Craig Campbell\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * Mousetrap is a simple keyboard shortcut library for Javascript with\n * no external dependencies\n *\n * @version 1.6.5\n * @url craig.is/killing/mice\n */\n(function(window, document, undefined) {\n\n    // Check if mousetrap is used inside browser, if not, return\n    if (!window) {\n        return;\n    }\n\n    /**\n     * mapping of special keycodes to their corresponding keys\n     *\n     * everything in this dictionary cannot use keypress events\n     * so it has to be here to map to the correct keycodes for\n     * keyup/keydown events\n     *\n     * @type {Object}\n     */\n    var _MAP = {\n        8: 'backspace',\n        9: 'tab',\n        13: 'enter',\n        16: 'shift',\n        17: 'ctrl',\n        18: 'alt',\n        20: 'capslock',\n        27: 'esc',\n        32: 'space',\n        33: 'pageup',\n        34: 'pagedown',\n        35: 'end',\n        36: 'home',\n        37: 'left',\n        38: 'up',\n        39: 'right',\n        40: 'down',\n        45: 'ins',\n        46: 'del',\n        91: 'meta',\n        93: 'meta',\n        224: 'meta'\n    };\n\n    /**\n     * mapping for special characters so they can support\n     *\n     * this dictionary is only used incase you want to bind a\n     * keyup or keydown event to one of these keys\n     *\n     * @type {Object}\n     */\n    var _KEYCODE_MAP = {\n        106: '*',\n        107: '+',\n        109: '-',\n        110: '.',\n        111 : '/',\n        186: ';',\n        187: '=',\n        188: ',',\n        189: '-',\n        190: '.',\n        191: '/',\n        192: '`',\n        219: '[',\n        220: '\\\\',\n        221: ']',\n        222: '\\''\n    };\n\n    /**\n     * this is a mapping of keys that require shift on a US keypad\n     * back to the non shift equivelents\n     *\n     * this is so you can use keyup events with these keys\n     *\n     * note that this will only work reliably on US keyboards\n     *\n     * @type {Object}\n     */\n    var _SHIFT_MAP = {\n        '~': '`',\n        '!': '1',\n        '@': '2',\n        '#': '3',\n        '$': '4',\n        '%': '5',\n        '^': '6',\n        '&': '7',\n        '*': '8',\n        '(': '9',\n        ')': '0',\n        '_': '-',\n        '+': '=',\n        ':': ';',\n        '\\\"': '\\'',\n        '<': ',',\n        '>': '.',\n        '?': '/',\n        '|': '\\\\'\n    };\n\n    /**\n     * this is a list of special strings you can use to map\n     * to modifier keys when you specify your keyboard shortcuts\n     *\n     * @type {Object}\n     */\n    var _SPECIAL_ALIASES = {\n        'option': 'alt',\n        'command': 'meta',\n        'return': 'enter',\n        'escape': 'esc',\n        'plus': '+',\n        'mod': /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? 'meta' : 'ctrl'\n    };\n\n    /**\n     * variable to store the flipped version of _MAP from above\n     * needed to check if we should use keypress or not when no action\n     * is specified\n     *\n     * @type {Object|undefined}\n     */\n    var _REVERSE_MAP;\n\n    /**\n     * loop through the f keys, f1 to f19 and add them to the map\n     * programatically\n     */\n    for (var i = 1; i < 20; ++i) {\n        _MAP[111 + i] = 'f' + i;\n    }\n\n    /**\n     * loop through to map numbers on the numeric keypad\n     */\n    for (i = 0; i <= 9; ++i) {\n\n        // This needs to use a string cause otherwise since 0 is falsey\n        // mousetrap will never fire for numpad 0 pressed as part of a keydown\n        // event.\n        //\n        // @see https://github.com/ccampbell/mousetrap/pull/258\n        _MAP[i + 96] = i.toString();\n    }\n\n    /**\n     * cross browser add event method\n     *\n     * @param {Element|HTMLDocument} object\n     * @param {string} type\n     * @param {Function} callback\n     * @returns void\n     */\n    function _addEvent(object, type, callback) {\n        if (object.addEventListener) {\n            object.addEventListener(type, callback, false);\n            return;\n        }\n\n        object.attachEvent('on' + type, callback);\n    }\n\n    /**\n     * takes the event and returns the key character\n     *\n     * @param {Event} e\n     * @return {string}\n     */\n    function _characterFromEvent(e) {\n\n        // for keypress events we should return the character as is\n        if (e.type == 'keypress') {\n            var character = String.fromCharCode(e.which);\n\n            // if the shift key is not pressed then it is safe to assume\n            // that we want the character to be lowercase.  this means if\n            // you accidentally have caps lock on then your key bindings\n            // will continue to work\n            //\n            // the only side effect that might not be desired is if you\n            // bind something like 'A' cause you want to trigger an\n            // event when capital A is pressed caps lock will no longer\n            // trigger the event.  shift+a will though.\n            if (!e.shiftKey) {\n                character = character.toLowerCase();\n            }\n\n            return character;\n        }\n\n        // for non keypress events the special maps are needed\n        if (_MAP[e.which]) {\n            return _MAP[e.which];\n        }\n\n        if (_KEYCODE_MAP[e.which]) {\n            return _KEYCODE_MAP[e.which];\n        }\n\n        // if it is not in the special map\n\n        // with keydown and keyup events the character seems to always\n        // come in as an uppercase character whether you are pressing shift\n        // or not.  we should make sure it is always lowercase for comparisons\n        return String.fromCharCode(e.which).toLowerCase();\n    }\n\n    /**\n     * checks if two arrays are equal\n     *\n     * @param {Array} modifiers1\n     * @param {Array} modifiers2\n     * @returns {boolean}\n     */\n    function _modifiersMatch(modifiers1, modifiers2) {\n        return modifiers1.sort().join(',') === modifiers2.sort().join(',');\n    }\n\n    /**\n     * takes a key event and figures out what the modifiers are\n     *\n     * @param {Event} e\n     * @returns {Array}\n     */\n    function _eventModifiers(e) {\n        var modifiers = [];\n\n        if (e.shiftKey) {\n            modifiers.push('shift');\n        }\n\n        if (e.altKey) {\n            modifiers.push('alt');\n        }\n\n        if (e.ctrlKey) {\n            modifiers.push('ctrl');\n        }\n\n        if (e.metaKey) {\n            modifiers.push('meta');\n        }\n\n        return modifiers;\n    }\n\n    /**\n     * prevents default for this event\n     *\n     * @param {Event} e\n     * @returns void\n     */\n    function _preventDefault(e) {\n        if (e.preventDefault) {\n            e.preventDefault();\n            return;\n        }\n\n        e.returnValue = false;\n    }\n\n    /**\n     * stops propogation for this event\n     *\n     * @param {Event} e\n     * @returns void\n     */\n    function _stopPropagation(e) {\n        if (e.stopPropagation) {\n            e.stopPropagation();\n            return;\n        }\n\n        e.cancelBubble = true;\n    }\n\n    /**\n     * determines if the keycode specified is a modifier key or not\n     *\n     * @param {string} key\n     * @returns {boolean}\n     */\n    function _isModifier(key) {\n        return key == 'shift' || key == 'ctrl' || key == 'alt' || key == 'meta';\n    }\n\n    /**\n     * reverses the map lookup so that we can look for specific keys\n     * to see what can and can't use keypress\n     *\n     * @return {Object}\n     */\n    function _getReverseMap() {\n        if (!_REVERSE_MAP) {\n            _REVERSE_MAP = {};\n            for (var key in _MAP) {\n\n                // pull out the numeric keypad from here cause keypress should\n                // be able to detect the keys from the character\n                if (key > 95 && key < 112) {\n                    continue;\n                }\n\n                if (_MAP.hasOwnProperty(key)) {\n                    _REVERSE_MAP[_MAP[key]] = key;\n                }\n            }\n        }\n        return _REVERSE_MAP;\n    }\n\n    /**\n     * picks the best action based on the key combination\n     *\n     * @param {string} key - character for key\n     * @param {Array} modifiers\n     * @param {string=} action passed in\n     */\n    function _pickBestAction(key, modifiers, action) {\n\n        // if no action was picked in we should try to pick the one\n        // that we think would work best for this key\n        if (!action) {\n            action = _getReverseMap()[key] ? 'keydown' : 'keypress';\n        }\n\n        // modifier keys don't work as expected with keypress,\n        // switch to keydown\n        if (action == 'keypress' && modifiers.length) {\n            action = 'keydown';\n        }\n\n        return action;\n    }\n\n    /**\n     * Converts from a string key combination to an array\n     *\n     * @param  {string} combination like \"command+shift+l\"\n     * @return {Array}\n     */\n    function _keysFromString(combination) {\n        if (combination === '+') {\n            return ['+'];\n        }\n\n        combination = combination.replace(/\\+{2}/g, '+plus');\n        return combination.split('+');\n    }\n\n    /**\n     * Gets info for a specific key combination\n     *\n     * @param  {string} combination key combination (\"command+s\" or \"a\" or \"*\")\n     * @param  {string=} action\n     * @returns {Object}\n     */\n    function _getKeyInfo(combination, action) {\n        var keys;\n        var key;\n        var i;\n        var modifiers = [];\n\n        // take the keys from this pattern and figure out what the actual\n        // pattern is all about\n        keys = _keysFromString(combination);\n\n        for (i = 0; i < keys.length; ++i) {\n            key = keys[i];\n\n            // normalize key names\n            if (_SPECIAL_ALIASES[key]) {\n                key = _SPECIAL_ALIASES[key];\n            }\n\n            // if this is not a keypress event then we should\n            // be smart about using shift keys\n            // this will only work for US keyboards however\n            if (action && action != 'keypress' && _SHIFT_MAP[key]) {\n                key = _SHIFT_MAP[key];\n                modifiers.push('shift');\n            }\n\n            // if this key is a modifier then add it to the list of modifiers\n            if (_isModifier(key)) {\n                modifiers.push(key);\n            }\n        }\n\n        // depending on what the key combination is\n        // we will try to pick the best event for it\n        action = _pickBestAction(key, modifiers, action);\n\n        return {\n            key: key,\n            modifiers: modifiers,\n            action: action\n        };\n    }\n\n    function _belongsTo(element, ancestor) {\n        if (element === null || element === document) {\n            return false;\n        }\n\n        if (element === ancestor) {\n            return true;\n        }\n\n        return _belongsTo(element.parentNode, ancestor);\n    }\n\n    function Mousetrap(targetElement) {\n        var self = this;\n\n        targetElement = targetElement || document;\n\n        if (!(self instanceof Mousetrap)) {\n            return new Mousetrap(targetElement);\n        }\n\n        /**\n         * element to attach key events to\n         *\n         * @type {Element}\n         */\n        self.target = targetElement;\n\n        /**\n         * a list of all the callbacks setup via Mousetrap.bind()\n         *\n         * @type {Object}\n         */\n        self._callbacks = {};\n\n        /**\n         * direct map of string combinations to callbacks used for trigger()\n         *\n         * @type {Object}\n         */\n        self._directMap = {};\n\n        /**\n         * keeps track of what level each sequence is at since multiple\n         * sequences can start out with the same sequence\n         *\n         * @type {Object}\n         */\n        var _sequenceLevels = {};\n\n        /**\n         * variable to store the setTimeout call\n         *\n         * @type {null|number}\n         */\n        var _resetTimer;\n\n        /**\n         * temporary state where we will ignore the next keyup\n         *\n         * @type {boolean|string}\n         */\n        var _ignoreNextKeyup = false;\n\n        /**\n         * temporary state where we will ignore the next keypress\n         *\n         * @type {boolean}\n         */\n        var _ignoreNextKeypress = false;\n\n        /**\n         * are we currently inside of a sequence?\n         * type of action (\"keyup\" or \"keydown\" or \"keypress\") or false\n         *\n         * @type {boolean|string}\n         */\n        var _nextExpectedAction = false;\n\n        /**\n         * resets all sequence counters except for the ones passed in\n         *\n         * @param {Object} doNotReset\n         * @returns void\n         */\n        function _resetSequences(doNotReset) {\n            doNotReset = doNotReset || {};\n\n            var activeSequences = false,\n                key;\n\n            for (key in _sequenceLevels) {\n                if (doNotReset[key]) {\n                    activeSequences = true;\n                    continue;\n                }\n                _sequenceLevels[key] = 0;\n            }\n\n            if (!activeSequences) {\n                _nextExpectedAction = false;\n            }\n        }\n\n        /**\n         * finds all callbacks that match based on the keycode, modifiers,\n         * and action\n         *\n         * @param {string} character\n         * @param {Array} modifiers\n         * @param {Event|Object} e\n         * @param {string=} sequenceName - name of the sequence we are looking for\n         * @param {string=} combination\n         * @param {number=} level\n         * @returns {Array}\n         */\n        function _getMatches(character, modifiers, e, sequenceName, combination, level) {\n            var i;\n            var callback;\n            var matches = [];\n            var action = e.type;\n\n            // if there are no events related to this keycode\n            if (!self._callbacks[character]) {\n                return [];\n            }\n\n            // if a modifier key is coming up on its own we should allow it\n            if (action == 'keyup' && _isModifier(character)) {\n                modifiers = [character];\n            }\n\n            // loop through all callbacks for the key that was pressed\n            // and see if any of them match\n            for (i = 0; i < self._callbacks[character].length; ++i) {\n                callback = self._callbacks[character][i];\n\n                // if a sequence name is not specified, but this is a sequence at\n                // the wrong level then move onto the next match\n                if (!sequenceName && callback.seq && _sequenceLevels[callback.seq] != callback.level) {\n                    continue;\n                }\n\n                // if the action we are looking for doesn't match the action we got\n                // then we should keep going\n                if (action != callback.action) {\n                    continue;\n                }\n\n                // if this is a keypress event and the meta key and control key\n                // are not pressed that means that we need to only look at the\n                // character, otherwise check the modifiers as well\n                //\n                // chrome will not fire a keypress if meta or control is down\n                // safari will fire a keypress if meta or meta+shift is down\n                // firefox will fire a keypress if meta or control is down\n                if ((action == 'keypress' && !e.metaKey && !e.ctrlKey) || _modifiersMatch(modifiers, callback.modifiers)) {\n\n                    // when you bind a combination or sequence a second time it\n                    // should overwrite the first one.  if a sequenceName or\n                    // combination is specified in this call it does just that\n                    //\n                    // @todo make deleting its own method?\n                    var deleteCombo = !sequenceName && callback.combo == combination;\n                    var deleteSequence = sequenceName && callback.seq == sequenceName && callback.level == level;\n                    if (deleteCombo || deleteSequence) {\n                        self._callbacks[character].splice(i, 1);\n                    }\n\n                    matches.push(callback);\n                }\n            }\n\n            return matches;\n        }\n\n        /**\n         * actually calls the callback function\n         *\n         * if your callback function returns false this will use the jquery\n         * convention - prevent default and stop propogation on the event\n         *\n         * @param {Function} callback\n         * @param {Event} e\n         * @returns void\n         */\n        function _fireCallback(callback, e, combo, sequence) {\n\n            // if this event should not happen stop here\n            if (self.stopCallback(e, e.target || e.srcElement, combo, sequence)) {\n                return;\n            }\n\n            if (callback(e, combo) === false) {\n                _preventDefault(e);\n                _stopPropagation(e);\n            }\n        }\n\n        /**\n         * handles a character key event\n         *\n         * @param {string} character\n         * @param {Array} modifiers\n         * @param {Event} e\n         * @returns void\n         */\n        self._handleKey = function(character, modifiers, e) {\n            var callbacks = _getMatches(character, modifiers, e);\n            var i;\n            var doNotReset = {};\n            var maxLevel = 0;\n            var processedSequenceCallback = false;\n\n            // Calculate the maxLevel for sequences so we can only execute the longest callback sequence\n            for (i = 0; i < callbacks.length; ++i) {\n                if (callbacks[i].seq) {\n                    maxLevel = Math.max(maxLevel, callbacks[i].level);\n                }\n            }\n\n            // loop through matching callbacks for this key event\n            for (i = 0; i < callbacks.length; ++i) {\n\n                // fire for all sequence callbacks\n                // this is because if for example you have multiple sequences\n                // bound such as \"g i\" and \"g t\" they both need to fire the\n                // callback for matching g cause otherwise you can only ever\n                // match the first one\n                if (callbacks[i].seq) {\n\n                    // only fire callbacks for the maxLevel to prevent\n                    // subsequences from also firing\n                    //\n                    // for example 'a option b' should not cause 'option b' to fire\n                    // even though 'option b' is part of the other sequence\n                    //\n                    // any sequences that do not match here will be discarded\n                    // below by the _resetSequences call\n                    if (callbacks[i].level != maxLevel) {\n                        continue;\n                    }\n\n                    processedSequenceCallback = true;\n\n                    // keep a list of which sequences were matches for later\n                    doNotReset[callbacks[i].seq] = 1;\n                    _fireCallback(callbacks[i].callback, e, callbacks[i].combo, callbacks[i].seq);\n                    continue;\n                }\n\n                // if there were no sequence matches but we are still here\n                // that means this is a regular match so we should fire that\n                if (!processedSequenceCallback) {\n                    _fireCallback(callbacks[i].callback, e, callbacks[i].combo);\n                }\n            }\n\n            // if the key you pressed matches the type of sequence without\n            // being a modifier (ie \"keyup\" or \"keypress\") then we should\n            // reset all sequences that were not matched by this event\n            //\n            // this is so, for example, if you have the sequence \"h a t\" and you\n            // type \"h e a r t\" it does not match.  in this case the \"e\" will\n            // cause the sequence to reset\n            //\n            // modifier keys are ignored because you can have a sequence\n            // that contains modifiers such as \"enter ctrl+space\" and in most\n            // cases the modifier key will be pressed before the next key\n            //\n            // also if you have a sequence such as \"ctrl+b a\" then pressing the\n            // \"b\" key will trigger a \"keypress\" and a \"keydown\"\n            //\n            // the \"keydown\" is expected when there is a modifier, but the\n            // \"keypress\" ends up matching the _nextExpectedAction since it occurs\n            // after and that causes the sequence to reset\n            //\n            // we ignore keypresses in a sequence that directly follow a keydown\n            // for the same character\n            var ignoreThisKeypress = e.type == 'keypress' && _ignoreNextKeypress;\n            if (e.type == _nextExpectedAction && !_isModifier(character) && !ignoreThisKeypress) {\n                _resetSequences(doNotReset);\n            }\n\n            _ignoreNextKeypress = processedSequenceCallback && e.type == 'keydown';\n        };\n\n        /**\n         * handles a keydown event\n         *\n         * @param {Event} e\n         * @returns void\n         */\n        function _handleKeyEvent(e) {\n\n            // normalize e.which for key events\n            // @see http://stackoverflow.com/questions/4285627/javascript-keycode-vs-charcode-utter-confusion\n            if (typeof e.which !== 'number') {\n                e.which = e.keyCode;\n            }\n\n            var character = _characterFromEvent(e);\n\n            // no character found then stop\n            if (!character) {\n                return;\n            }\n\n            // need to use === for the character check because the character can be 0\n            if (e.type == 'keyup' && _ignoreNextKeyup === character) {\n                _ignoreNextKeyup = false;\n                return;\n            }\n\n            self.handleKey(character, _eventModifiers(e), e);\n        }\n\n        /**\n         * called to set a 1 second timeout on the specified sequence\n         *\n         * this is so after each key press in the sequence you have 1 second\n         * to press the next key before you have to start over\n         *\n         * @returns void\n         */\n        function _resetSequenceTimer() {\n            clearTimeout(_resetTimer);\n            _resetTimer = setTimeout(_resetSequences, 1000);\n        }\n\n        /**\n         * binds a key sequence to an event\n         *\n         * @param {string} combo - combo specified in bind call\n         * @param {Array} keys\n         * @param {Function} callback\n         * @param {string=} action\n         * @returns void\n         */\n        function _bindSequence(combo, keys, callback, action) {\n\n            // start off by adding a sequence level record for this combination\n            // and setting the level to 0\n            _sequenceLevels[combo] = 0;\n\n            /**\n             * callback to increase the sequence level for this sequence and reset\n             * all other sequences that were active\n             *\n             * @param {string} nextAction\n             * @returns {Function}\n             */\n            function _increaseSequence(nextAction) {\n                return function() {\n                    _nextExpectedAction = nextAction;\n                    ++_sequenceLevels[combo];\n                    _resetSequenceTimer();\n                };\n            }\n\n            /**\n             * wraps the specified callback inside of another function in order\n             * to reset all sequence counters as soon as this sequence is done\n             *\n             * @param {Event} e\n             * @returns void\n             */\n            function _callbackAndReset(e) {\n                _fireCallback(callback, e, combo);\n\n                // we should ignore the next key up if the action is key down\n                // or keypress.  this is so if you finish a sequence and\n                // release the key the final key will not trigger a keyup\n                if (action !== 'keyup') {\n                    _ignoreNextKeyup = _characterFromEvent(e);\n                }\n\n                // weird race condition if a sequence ends with the key\n                // another sequence begins with\n                setTimeout(_resetSequences, 10);\n            }\n\n            // loop through keys one at a time and bind the appropriate callback\n            // function.  for any key leading up to the final one it should\n            // increase the sequence. after the final, it should reset all sequences\n            //\n            // if an action is specified in the original bind call then that will\n            // be used throughout.  otherwise we will pass the action that the\n            // next key in the sequence should match.  this allows a sequence\n            // to mix and match keypress and keydown events depending on which\n            // ones are better suited to the key provided\n            for (var i = 0; i < keys.length; ++i) {\n                var isFinal = i + 1 === keys.length;\n                var wrappedCallback = isFinal ? _callbackAndReset : _increaseSequence(action || _getKeyInfo(keys[i + 1]).action);\n                _bindSingle(keys[i], wrappedCallback, action, combo, i);\n            }\n        }\n\n        /**\n         * binds a single keyboard combination\n         *\n         * @param {string} combination\n         * @param {Function} callback\n         * @param {string=} action\n         * @param {string=} sequenceName - name of sequence if part of sequence\n         * @param {number=} level - what part of the sequence the command is\n         * @returns void\n         */\n        function _bindSingle(combination, callback, action, sequenceName, level) {\n\n            // store a direct mapped reference for use with Mousetrap.trigger\n            self._directMap[combination + ':' + action] = callback;\n\n            // make sure multiple spaces in a row become a single space\n            combination = combination.replace(/\\s+/g, ' ');\n\n            var sequence = combination.split(' ');\n            var info;\n\n            // if this pattern is a sequence of keys then run through this method\n            // to reprocess each pattern one key at a time\n            if (sequence.length > 1) {\n                _bindSequence(combination, sequence, callback, action);\n                return;\n            }\n\n            info = _getKeyInfo(combination, action);\n\n            // make sure to initialize array if this is the first time\n            // a callback is added for this key\n            self._callbacks[info.key] = self._callbacks[info.key] || [];\n\n            // remove an existing match if there is one\n            _getMatches(info.key, info.modifiers, {type: info.action}, sequenceName, combination, level);\n\n            // add this call back to the array\n            // if it is a sequence put it at the beginning\n            // if not put it at the end\n            //\n            // this is important because the way these are processed expects\n            // the sequence ones to come first\n            self._callbacks[info.key][sequenceName ? 'unshift' : 'push']({\n                callback: callback,\n                modifiers: info.modifiers,\n                action: info.action,\n                seq: sequenceName,\n                level: level,\n                combo: combination\n            });\n        }\n\n        /**\n         * binds multiple combinations to the same callback\n         *\n         * @param {Array} combinations\n         * @param {Function} callback\n         * @param {string|undefined} action\n         * @returns void\n         */\n        self._bindMultiple = function(combinations, callback, action) {\n            for (var i = 0; i < combinations.length; ++i) {\n                _bindSingle(combinations[i], callback, action);\n            }\n        };\n\n        // start!\n        _addEvent(targetElement, 'keypress', _handleKeyEvent);\n        _addEvent(targetElement, 'keydown', _handleKeyEvent);\n        _addEvent(targetElement, 'keyup', _handleKeyEvent);\n    }\n\n    /**\n     * binds an event to mousetrap\n     *\n     * can be a single key, a combination of keys separated with +,\n     * an array of keys, or a sequence of keys separated by spaces\n     *\n     * be sure to list the modifier keys first to make sure that the\n     * correct key ends up getting bound (the last key in the pattern)\n     *\n     * @param {string|Array} keys\n     * @param {Function} callback\n     * @param {string=} action - 'keypress', 'keydown', or 'keyup'\n     * @returns void\n     */\n    Mousetrap.prototype.bind = function(keys, callback, action) {\n        var self = this;\n        keys = keys instanceof Array ? keys : [keys];\n        self._bindMultiple.call(self, keys, callback, action);\n        return self;\n    };\n\n    /**\n     * unbinds an event to mousetrap\n     *\n     * the unbinding sets the callback function of the specified key combo\n     * to an empty function and deletes the corresponding key in the\n     * _directMap dict.\n     *\n     * TODO: actually remove this from the _callbacks dictionary instead\n     * of binding an empty function\n     *\n     * the keycombo+action has to be exactly the same as\n     * it was defined in the bind method\n     *\n     * @param {string|Array} keys\n     * @param {string} action\n     * @returns void\n     */\n    Mousetrap.prototype.unbind = function(keys, action) {\n        var self = this;\n        return self.bind.call(self, keys, function() {}, action);\n    };\n\n    /**\n     * triggers an event that has already been bound\n     *\n     * @param {string} keys\n     * @param {string=} action\n     * @returns void\n     */\n    Mousetrap.prototype.trigger = function(keys, action) {\n        var self = this;\n        if (self._directMap[keys + ':' + action]) {\n            self._directMap[keys + ':' + action]({}, keys);\n        }\n        return self;\n    };\n\n    /**\n     * resets the library back to its initial state.  this is useful\n     * if you want to clear out the current keyboard shortcuts and bind\n     * new ones - for example if you switch to another page\n     *\n     * @returns void\n     */\n    Mousetrap.prototype.reset = function() {\n        var self = this;\n        self._callbacks = {};\n        self._directMap = {};\n        return self;\n    };\n\n    /**\n     * should we stop this event before firing off callbacks\n     *\n     * @param {Event} e\n     * @param {Element} element\n     * @return {boolean}\n     */\n    Mousetrap.prototype.stopCallback = function(e, element) {\n        var self = this;\n\n        // if the element has the class \"mousetrap\" then no need to stop\n        if ((' ' + element.className + ' ').indexOf(' mousetrap ') > -1) {\n            return false;\n        }\n\n        if (_belongsTo(element, self.target)) {\n            return false;\n        }\n\n        // Events originating from a shadow DOM are re-targetted and `e.target` is the shadow host,\n        // not the initial event target in the shadow tree. Note that not all events cross the\n        // shadow boundary.\n        // For shadow trees with `mode: 'open'`, the initial event target is the first element in\n        // the event\u2019s composed path. For shadow trees with `mode: 'closed'`, the initial event\n        // target cannot be obtained.\n        if ('composedPath' in e && typeof e.composedPath === 'function') {\n            // For open shadow trees, update `element` so that the following check works.\n            var initialEventTarget = e.composedPath()[0];\n            if (initialEventTarget !== e.target) {\n                element = initialEventTarget;\n            }\n        }\n\n        // stop for input, select, and textarea\n        return element.tagName == 'INPUT' || element.tagName == 'SELECT' || element.tagName == 'TEXTAREA' || element.isContentEditable;\n    };\n\n    /**\n     * exposes _handleKey publicly so it can be overwritten by extensions\n     */\n    Mousetrap.prototype.handleKey = function() {\n        var self = this;\n        return self._handleKey.apply(self, arguments);\n    };\n\n    /**\n     * allow custom key mappings\n     */\n    Mousetrap.addKeycodes = function(object) {\n        for (var key in object) {\n            if (object.hasOwnProperty(key)) {\n                _MAP[key] = object[key];\n            }\n        }\n        _REVERSE_MAP = null;\n    };\n\n    /**\n     * Init the global mousetrap functions\n     *\n     * This method is needed to allow the global mousetrap functions to work\n     * now that mousetrap is a constructor function.\n     */\n    Mousetrap.init = function() {\n        var documentMousetrap = Mousetrap(document);\n        for (var method in documentMousetrap) {\n            if (method.charAt(0) !== '_') {\n                Mousetrap[method] = (function(method) {\n                    return function() {\n                        return documentMousetrap[method].apply(documentMousetrap, arguments);\n                    };\n                } (method));\n            }\n        }\n    };\n\n    Mousetrap.init();\n\n    // expose mousetrap to the global object\n    window.Mousetrap = Mousetrap;\n\n    // expose as a common js module\n    if (typeof module !== 'undefined' && module.exports) {\n        module.exports = Mousetrap;\n    }\n\n    // expose mousetrap as an AMD module\n    if (typeof define === 'function' && define.amd) {\n        define(function() {\n            return Mousetrap;\n        });\n    }\n}) (typeof window !== 'undefined' ? window : null, typeof  window !== 'undefined' ? document : null);\n", "/*\n\nel(\"div\")\n  .id(\"app\")\n  .class(\"blue\")\n  .class(\"big\")\n  .attr(\"atrribute\", \"value\")\n  .children(\n    el(\"div\").element,\n    el(\"button\"),\n      .on(\"click\", () => console.log(\"hey\"))\n      .element,\n  ).element\n\n*/\n\nexport class Elbuilder {\n  element: HTMLElement;\n\n  constructor(element: HTMLElement) {\n    this.element = element;\n  }\n\n  on<K extends keyof HTMLElementEventMap>(\n    type: K,\n    listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any,\n    options?: boolean | AddEventListenerOptions,\n  ) {\n    this.element.addEventListener(type, listener, options);\n    return this;\n  }\n\n  off<K extends keyof HTMLElementEventMap>(\n    type: K,\n    listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any,\n  ) {\n    this.element.removeEventListener(type, listener);\n    return this;\n  }\n\n  attr(name: string, value: string) {\n    this.element.setAttribute(name, value);\n    return this;\n  }\n\n  id(id: string) {\n    this.element.id = id;\n    return this;\n  }\n\n  class(className: string) {\n    this.element.classList.add(className);\n    return this;\n  }\n\n  hook(fn: (e: Elbuilder) => void) {\n    fn(this);\n    return this;\n  }\n\n  inner(contents: string) {\n    this.element.innerHTML = contents;\n    return this;\n  }\n\n  style(key: string, value: string) {\n    this.element.style[key] = value;\n    return this;\n  }\n\n  children(...els: HTMLElement[]) {\n    els.forEach((el) => {\n      this.element.appendChild(el);\n    });\n    return this;\n  }\n\n  parent(element: Element) {\n    element.appendChild(this.element);\n    return this;\n  }\n}\n\nexport function el(tag: string) {\n  return new Elbuilder(document.createElement(tag));\n}\n", "// The programming goals of Split.js are to deliver readable, understandable and\n// maintainable code, while at the same time manually optimizing for tiny minified file size,\n// browser compatibility without additional requirements\n// and very few assumptions about the user's page layout.\nconst global = typeof window !== \"undefined\" ? window : null;\nconst ssr = global === null;\nconst document = !ssr ? global.document : undefined;\n\n// Save a couple long function names that are used frequently.\n// This optimization saves around 400 bytes.\nconst addEventListener = \"addEventListener\";\nconst removeEventListener = \"removeEventListener\";\nconst getBoundingClientRect = \"getBoundingClientRect\";\nconst gutterStartDragging = \"_a\";\nconst aGutterSize = \"_b\";\nconst bGutterSize = \"_c\";\nconst HORIZONTAL = \"horizontal\";\nconst NOOP = () => false;\n\n// Helper function determines which prefixes of CSS calc we need.\n// We only need to do this once on startup, when this anonymous function is called.\n//\n// Tests -webkit, -moz and -o prefixes. Modified from StackOverflow:\n// http://stackoverflow.com/questions/16625140/js-feature-detection-to-detect-the-usage-of-webkit-calc-over-calc/16625167#16625167\nconst calc = ssr ? \"calc\" : `${\n  [\"\", \"-webkit-\", \"-moz-\", \"-o-\"]\n    .filter((prefix) => {\n      const el = document.createElement(\"div\");\n      el.style.cssText = `width:${prefix}calc(9px)`;\n      return !!el.style.length;\n    })\n    .shift()\n}calc`;\n\n// Helper function checks if its argument is a string-like type\nconst isString = (v) => typeof v === \"string\" || v instanceof String;\n\n// Helper function allows elements and string selectors to be used\n// interchangeably. In either case an element is returned. This allows us to\n// do `Split([elem1, elem2])` as well as `Split(['#id1', '#id2'])`.\nconst elementOrSelector = (el) => {\n  if (isString(el)) {\n    const ele = document.querySelector(el);\n    if (!ele) {\n      throw new Error(`Selector ${el} did not match a DOM element`);\n    }\n    return ele;\n  }\n\n  return el;\n};\n\n// Helper function gets a property from the properties object, with a default fallback\nconst getOption = (options, propName, def) => {\n  const value = options[propName];\n  if (value !== undefined) {\n    return value;\n  }\n  return def;\n};\n\nconst getGutterSize = (gutterSize, isFirst, isLast, gutterAlign) => {\n  if (isFirst) {\n    if (gutterAlign === \"end\") {\n      return 0;\n    }\n    if (gutterAlign === \"center\") {\n      return gutterSize / 2;\n    }\n  } else if (isLast) {\n    if (gutterAlign === \"start\") {\n      return 0;\n    }\n    if (gutterAlign === \"center\") {\n      return gutterSize / 2;\n    }\n  }\n\n  return gutterSize;\n};\n\n// Default options\nconst defaultGutterFn = (i, gutterDirection) => {\n  const gut = document.createElement(\"div\");\n  gut.className = `gutter gutter-${gutterDirection}`;\n  return gut;\n};\n\nconst defaultElementStyleFn = (dim, size, gutSize) => {\n  const style = {};\n\n  if (!isString(size)) {\n    style[dim] = `${calc}(${size}% - ${gutSize}px)`;\n  } else {\n    style[dim] = size;\n  }\n\n  return style;\n};\n\nconst defaultGutterStyleFn = (dim, gutSize) => ({ [dim]: `${gutSize}px` });\n\n// The main function to initialize a split. Split.js thinks about each pair\n// of elements as an independant pair. Dragging the gutter between two elements\n// only changes the dimensions of elements in that pair. This is key to understanding\n// how the following functions operate, since each function is bound to a pair.\n//\n// A pair object is shaped like this:\n//\n// {\n//     a: DOM element,\n//     b: DOM element,\n//     aMin: Number,\n//     bMin: Number,\n//     dragging: Boolean,\n//     parent: DOM element,\n//     direction: 'horizontal' | 'vertical'\n// }\n//\n// The basic sequence:\n//\n// 1. Set defaults to something sane. `options` doesn't have to be passed at all.\n// 2. Initialize a bunch of strings based on the direction we're splitting.\n//    A lot of the behavior in the rest of the library is paramatized down to\n//    rely on CSS strings and classes.\n// 3. Define the dragging helper functions, and a few helpers to go with them.\n// 4. Loop through the elements while pairing them off. Every pair gets an\n//    `pair` object and a gutter.\n// 5. Actually size the pair elements, insert gutters and attach event listeners.\nconst Split = (idsOption, options = {}) => {\n  if (ssr) return {};\n\n  let ids = idsOption;\n  let dimension;\n  let clientAxis;\n  let position;\n  let positionEnd;\n  let clientSize;\n  let elements;\n\n  // Allow HTMLCollection to be used as an argument when supported\n  if (Array.from) {\n    ids = Array.from(ids);\n  }\n\n  // All DOM elements in the split should have a common parent. We can grab\n  // the first elements parent and hope users read the docs because the\n  // behavior will be whacky otherwise.\n  const firstElement = elementOrSelector(ids[0]);\n  const parent = firstElement.parentNode;\n  const parentStyle = getComputedStyle ? getComputedStyle(parent) : null;\n  const parentFlexDirection = parentStyle ? parentStyle.flexDirection : null;\n\n  // Set default options.sizes to equal percentages of the parent element.\n  let sizes = getOption(options, \"sizes\") || ids.map(() => 100 / ids.length);\n\n  // Standardize minSize and maxSize to an array if it isn't already.\n  // This allows minSize and maxSize to be passed as a number.\n  const minSize = getOption(options, \"minSize\", 100);\n  const minSizes = Array.isArray(minSize) ? minSize : ids.map(() => minSize);\n  const maxSize = getOption(options, \"maxSize\", Infinity);\n  const maxSizes = Array.isArray(maxSize) ? maxSize : ids.map(() => maxSize);\n\n  // Get other options\n  const expandToMin = getOption(options, \"expandToMin\", false);\n  const gutterSize = getOption(options, \"gutterSize\", 10);\n  const gutterAlign = getOption(options, \"gutterAlign\", \"center\");\n  const snapOffset = getOption(options, \"snapOffset\", 30);\n  const dragInterval = getOption(options, \"dragInterval\", 1);\n  const direction = getOption(options, \"direction\", HORIZONTAL);\n  const cursor = getOption(\n    options,\n    \"cursor\",\n    direction === HORIZONTAL ? \"col-resize\" : \"row-resize\",\n  );\n  const gutter = getOption(options, \"gutter\", defaultGutterFn);\n  const elementStyle = getOption(\n    options,\n    \"elementStyle\",\n    defaultElementStyleFn,\n  );\n  const gutterStyle = getOption(options, \"gutterStyle\", defaultGutterStyleFn);\n\n  // 2. Initialize a bunch of strings based on the direction we're splitting.\n  // A lot of the behavior in the rest of the library is paramatized down to\n  // rely on CSS strings and classes.\n  if (direction === HORIZONTAL) {\n    dimension = \"width\";\n    clientAxis = \"clientX\";\n    position = \"left\";\n    positionEnd = \"right\";\n    clientSize = \"clientWidth\";\n  } else if (direction === \"vertical\") {\n    dimension = \"height\";\n    clientAxis = \"clientY\";\n    position = \"top\";\n    positionEnd = \"bottom\";\n    clientSize = \"clientHeight\";\n  }\n\n  // 3. Define the dragging helper functions, and a few helpers to go with them.\n  // Each helper is bound to a pair object that contains its metadata. This\n  // also makes it easy to store references to listeners that that will be\n  // added and removed.\n  //\n  // Even though there are no other functions contained in them, aliasing\n  // this to self saves 50 bytes or so since it's used so frequently.\n  //\n  // The pair object saves metadata like dragging state, position and\n  // event listener references.\n\n  function setElementSize(el, size, gutSize, i) {\n    // Split.js allows setting sizes via numbers (ideally), or if you must,\n    // by string, like '300px'. This is less than ideal, because it breaks\n    // the fluid layout that `calc(% - px)` provides. You're on your own if you do that,\n    // make sure you calculate the gutter size by hand.\n    const style = elementStyle(dimension, size, gutSize, i);\n\n    Object.keys(style).forEach((prop) => {\n      // eslint-disable-next-line no-param-reassign\n      el.style[prop] = style[prop];\n    });\n  }\n\n  function setGutterSize(gutterElement, gutSize, i) {\n    const style = gutterStyle(dimension, gutSize, i);\n\n    Object.keys(style).forEach((prop) => {\n      // eslint-disable-next-line no-param-reassign\n      gutterElement.style[prop] = style[prop];\n    });\n  }\n\n  function getSizes() {\n    return elements.map((element) => element.size);\n  }\n\n  // Supports touch events, but not multitouch, so only the first\n  // finger `touches[0]` is counted.\n  function getMousePosition(e) {\n    if (\"touches\" in e) return e.touches[0][clientAxis];\n    return e[clientAxis];\n  }\n\n  // Actually adjust the size of elements `a` and `b` to `offset` while dragging.\n  // calc is used to allow calc(percentage + gutterpx) on the whole split instance,\n  // which allows the viewport to be resized without additional logic.\n  // Element a's size is the same as offset. b's size is total size - a size.\n  // Both sizes are calculated from the initial parent percentage,\n  // then the gutter size is subtracted.\n  function adjust(offset) {\n    const a = elements[this.a];\n    const b = elements[this.b];\n    const percentage = a.size + b.size;\n\n    a.size = (offset / this.size) * percentage;\n    b.size = percentage - (offset / this.size) * percentage;\n\n    setElementSize(a.element, a.size, this[aGutterSize], a.i);\n    setElementSize(b.element, b.size, this[bGutterSize], b.i);\n  }\n\n  // drag, where all the magic happens. The logic is really quite simple:\n  //\n  // 1. Ignore if the pair is not dragging.\n  // 2. Get the offset of the event.\n  // 3. Snap offset to min if within snappable range (within min + snapOffset).\n  // 4. Actually adjust each element in the pair to offset.\n  //\n  // ---------------------------------------------------------------------\n  // |    | <- a.minSize               ||              b.minSize -> |    |\n  // |    |  | <- this.snapOffset      ||     this.snapOffset -> |  |    |\n  // |    |  |                         ||                        |  |    |\n  // |    |  |                         ||                        |  |    |\n  // ---------------------------------------------------------------------\n  // | <- this.start                                        this.size -> |\n  function drag(e) {\n    let offset;\n    const a = elements[this.a];\n    const b = elements[this.b];\n\n    if (!this.dragging) return;\n\n    // Get the offset of the event from the first side of the\n    // pair `this.start`. Then offset by the initial position of the\n    // mouse compared to the gutter size.\n    offset = getMousePosition(e) -\n      this.start +\n      (this[aGutterSize] - this.dragOffset);\n\n    if (dragInterval > 1) {\n      offset = Math.round(offset / dragInterval) * dragInterval;\n    }\n\n    // If within snapOffset of min or max, set offset to min or max.\n    // snapOffset buffers a.minSize and b.minSize, so logic is opposite for both.\n    // Include the appropriate gutter sizes to prevent overflows.\n    if (offset <= a.minSize + snapOffset + this[aGutterSize]) {\n      offset = a.minSize + this[aGutterSize];\n    } else if (\n      offset >=\n        this.size - (b.minSize + snapOffset + this[bGutterSize])\n    ) {\n      offset = this.size - (b.minSize + this[bGutterSize]);\n    }\n\n    if (offset >= a.maxSize - snapOffset + this[aGutterSize]) {\n      offset = a.maxSize + this[aGutterSize];\n    } else if (\n      offset <=\n        this.size - (b.maxSize - snapOffset + this[bGutterSize])\n    ) {\n      offset = this.size - (b.maxSize + this[bGutterSize]);\n    }\n\n    // Actually adjust the size.\n    adjust.call(this, offset);\n\n    // Call the drag callback continously. Don't do anything too intensive\n    // in this callback.\n    getOption(options, \"onDrag\", NOOP)(getSizes());\n  }\n\n  // Cache some important sizes when drag starts, so we don't have to do that\n  // continously:\n  //\n  // `size`: The total size of the pair. First + second + first gutter + second gutter.\n  // `start`: The leading side of the first element.\n  //\n  // ------------------------------------------------\n  // |      aGutterSize -> |||                      |\n  // |                     |||                      |\n  // |                     |||                      |\n  // |                     ||| <- bGutterSize       |\n  // ------------------------------------------------\n  // | <- start                             size -> |\n  function calculateSizes() {\n    // Figure out the parent size minus padding.\n    const a = elements[this.a].element;\n    const b = elements[this.b].element;\n\n    const aBounds = a[getBoundingClientRect]();\n    const bBounds = b[getBoundingClientRect]();\n\n    this.size = aBounds[dimension] +\n      bBounds[dimension] +\n      this[aGutterSize] +\n      this[bGutterSize];\n    this.start = aBounds[position];\n    this.end = aBounds[positionEnd];\n  }\n\n  function innerSize(element) {\n    // Return nothing if getComputedStyle is not supported (< IE9)\n    // Or if parent element has no layout yet\n    if (!getComputedStyle) return null;\n\n    const computedStyle = getComputedStyle(element);\n\n    if (!computedStyle) return null;\n\n    let size = element[clientSize];\n\n    if (size === 0) return null;\n\n    if (direction === HORIZONTAL) {\n      size -= parseFloat(computedStyle.paddingLeft) +\n        parseFloat(computedStyle.paddingRight);\n    } else {\n      size -= parseFloat(computedStyle.paddingTop) +\n        parseFloat(computedStyle.paddingBottom);\n    }\n\n    return size;\n  }\n\n  // When specifying percentage sizes that are less than the computed\n  // size of the element minus the gutter, the lesser percentages must be increased\n  // (and decreased from the other elements) to make space for the pixels\n  // subtracted by the gutters.\n  function trimToMin(sizesToTrim) {\n    // Try to get inner size of parent element.\n    // If it's no supported, return original sizes.\n    const parentSize = innerSize(parent);\n    if (parentSize === null) {\n      return sizesToTrim;\n    }\n\n    if (minSizes.reduce((a, b) => a + b, 0) > parentSize) {\n      return sizesToTrim;\n    }\n\n    // Keep track of the excess pixels, the amount of pixels over the desired percentage\n    // Also keep track of the elements with pixels to spare, to decrease after if needed\n    let excessPixels = 0;\n    const toSpare = [];\n\n    const pixelSizes = sizesToTrim.map((size, i) => {\n      // Convert requested percentages to pixel sizes\n      const pixelSize = (parentSize * size) / 100;\n      const elementGutterSize = getGutterSize(\n        gutterSize,\n        i === 0,\n        i === sizesToTrim.length - 1,\n        gutterAlign,\n      );\n      const elementMinSize = minSizes[i] + elementGutterSize;\n\n      // If element is too smal, increase excess pixels by the difference\n      // and mark that it has no pixels to spare\n      if (pixelSize < elementMinSize) {\n        excessPixels += elementMinSize - pixelSize;\n        toSpare.push(0);\n        return elementMinSize;\n      }\n\n      // Otherwise, mark the pixels it has to spare and return it's original size\n      toSpare.push(pixelSize - elementMinSize);\n      return pixelSize;\n    });\n\n    // If nothing was adjusted, return the original sizes\n    if (excessPixels === 0) {\n      return sizesToTrim;\n    }\n\n    return pixelSizes.map((pixelSize, i) => {\n      let newPixelSize = pixelSize;\n\n      // While there's still pixels to take, and there's enough pixels to spare,\n      // take as many as possible up to the total excess pixels\n      if (excessPixels > 0 && toSpare[i] - excessPixels > 0) {\n        const takenPixels = Math.min(\n          excessPixels,\n          toSpare[i] - excessPixels,\n        );\n\n        // Subtract the amount taken for the next iteration\n        excessPixels -= takenPixels;\n        newPixelSize = pixelSize - takenPixels;\n      }\n\n      // Return the pixel size adjusted as a percentage\n      return (newPixelSize / parentSize) * 100;\n    });\n  }\n\n  // stopDragging is very similar to startDragging in reverse.\n  function stopDragging() {\n    const self = this;\n    const a = elements[self.a].element;\n    const b = elements[self.b].element;\n\n    if (self.dragging) {\n      getOption(options, \"onDragEnd\", NOOP)(getSizes());\n    }\n\n    self.dragging = false;\n\n    // Remove the stored event listeners. This is why we store them.\n    global[removeEventListener](\"mouseup\", self.stop);\n    global[removeEventListener](\"touchend\", self.stop);\n    global[removeEventListener](\"touchcancel\", self.stop);\n    global[removeEventListener](\"mousemove\", self.move);\n    global[removeEventListener](\"touchmove\", self.move);\n\n    // Clear bound function references\n    self.stop = null;\n    self.move = null;\n\n    a[removeEventListener](\"selectstart\", NOOP);\n    a[removeEventListener](\"dragstart\", NOOP);\n    b[removeEventListener](\"selectstart\", NOOP);\n    b[removeEventListener](\"dragstart\", NOOP);\n\n    a.style.userSelect = \"\";\n    a.style.webkitUserSelect = \"\";\n    a.style.MozUserSelect = \"\";\n    a.style.pointerEvents = \"\";\n\n    b.style.userSelect = \"\";\n    b.style.webkitUserSelect = \"\";\n    b.style.MozUserSelect = \"\";\n    b.style.pointerEvents = \"\";\n\n    self.gutter.style.cursor = \"\";\n    self.parent.style.cursor = \"\";\n    document.body.style.cursor = \"\";\n  }\n\n  // startDragging calls `calculateSizes` to store the inital size in the pair object.\n  // It also adds event listeners for mouse/touch events,\n  // and prevents selection while dragging so avoid the selecting text.\n  function startDragging(e) {\n    // Right-clicking can't start dragging.\n    if (\"button\" in e && e.button !== 0) {\n      return;\n    }\n\n    // Alias frequently used variables to save space. 200 bytes.\n    const self = this;\n    const a = elements[self.a].element;\n    const b = elements[self.b].element;\n\n    // Call the onDragStart callback.\n    if (!self.dragging) {\n      getOption(options, \"onDragStart\", NOOP)(getSizes());\n    }\n\n    // Don't actually drag the element. We emulate that in the drag function.\n    e.preventDefault();\n\n    // Set the dragging property of the pair object.\n    self.dragging = true;\n\n    // Create two event listeners bound to the same pair object and store\n    // them in the pair object.\n    self.move = drag.bind(self);\n    self.stop = stopDragging.bind(self);\n\n    // All the binding. `window` gets the stop events in case we drag out of the elements.\n    global[addEventListener](\"mouseup\", self.stop);\n    global[addEventListener](\"touchend\", self.stop);\n    global[addEventListener](\"touchcancel\", self.stop);\n    global[addEventListener](\"mousemove\", self.move);\n    global[addEventListener](\"touchmove\", self.move);\n\n    // Disable selection. Disable!\n    a[addEventListener](\"selectstart\", NOOP);\n    a[addEventListener](\"dragstart\", NOOP);\n    b[addEventListener](\"selectstart\", NOOP);\n    b[addEventListener](\"dragstart\", NOOP);\n\n    a.style.userSelect = \"none\";\n    a.style.webkitUserSelect = \"none\";\n    a.style.MozUserSelect = \"none\";\n    a.style.pointerEvents = \"none\";\n\n    b.style.userSelect = \"none\";\n    b.style.webkitUserSelect = \"none\";\n    b.style.MozUserSelect = \"none\";\n    b.style.pointerEvents = \"none\";\n\n    // Set the cursor at multiple levels\n    self.gutter.style.cursor = cursor;\n    self.parent.style.cursor = cursor;\n    document.body.style.cursor = cursor;\n\n    // Cache the initial sizes of the pair.\n    calculateSizes.call(self);\n\n    // Determine the position of the mouse compared to the gutter\n    self.dragOffset = getMousePosition(e) - self.end;\n  }\n\n  // adjust sizes to ensure percentage is within min size and gutter.\n  sizes = trimToMin(sizes);\n\n  // 5. Create pair and element objects. Each pair has an index reference to\n  // elements `a` and `b` of the pair (first and second elements).\n  // Loop through the elements while pairing them off. Every pair gets a\n  // `pair` object and a gutter.\n  //\n  // Basic logic:\n  //\n  // - Starting with the second element `i > 0`, create `pair` objects with\n  //   `a = i - 1` and `b = i`\n  // - Set gutter sizes based on the _pair_ being first/last. The first and last\n  //   pair have gutterSize / 2, since they only have one half gutter, and not two.\n  // - Create gutter elements and add event listeners.\n  // - Set the size of the elements, minus the gutter sizes.\n  //\n  // -----------------------------------------------------------------------\n  // |     i=0     |         i=1         |        i=2       |      i=3     |\n  // |             |                     |                  |              |\n  // |           pair 0                pair 1             pair 2           |\n  // |             |                     |                  |              |\n  // -----------------------------------------------------------------------\n  const pairs = [];\n  elements = ids.map((id, i) => {\n    // Create the element object.\n    const element = {\n      element: elementOrSelector(id),\n      size: sizes[i],\n      minSize: minSizes[i],\n      maxSize: maxSizes[i],\n      i,\n    };\n\n    let pair;\n\n    if (i > 0) {\n      // Create the pair object with its metadata.\n      pair = {\n        a: i - 1,\n        b: i,\n        dragging: false,\n        direction,\n        parent,\n      };\n\n      pair[aGutterSize] = getGutterSize(\n        gutterSize,\n        i - 1 === 0,\n        false,\n        gutterAlign,\n      );\n      pair[bGutterSize] = getGutterSize(\n        gutterSize,\n        false,\n        i === ids.length - 1,\n        gutterAlign,\n      );\n\n      // if the parent has a reverse flex-direction, switch the pair elements.\n      if (\n        parentFlexDirection === \"row-reverse\" ||\n        parentFlexDirection === \"column-reverse\"\n      ) {\n        const temp = pair.a;\n        pair.a = pair.b;\n        pair.b = temp;\n      }\n    }\n\n    // Determine the size of the current element. IE8 is supported by\n    // staticly assigning sizes without draggable gutters. Assigns a string\n    // to `size`.\n    //\n    // Create gutter elements for each pair.\n    if (i > 0) {\n      const gutterElement = gutter(i, direction, element.element);\n      setGutterSize(gutterElement, gutterSize, i);\n\n      // Save bound event listener for removal later\n      pair[gutterStartDragging] = startDragging.bind(pair);\n\n      // Attach bound event listener\n      gutterElement[addEventListener](\n        \"mousedown\",\n        pair[gutterStartDragging],\n      );\n      gutterElement[addEventListener](\n        \"touchstart\",\n        pair[gutterStartDragging],\n      );\n\n      parent.insertBefore(gutterElement, element.element);\n\n      pair.gutter = gutterElement;\n    }\n\n    setElementSize(\n      element.element,\n      element.size,\n      getGutterSize(\n        gutterSize,\n        i === 0,\n        i === ids.length - 1,\n        gutterAlign,\n      ),\n      i,\n    );\n\n    // After the first iteration, and we have a pair object, append it to the\n    // list of pairs.\n    if (i > 0) {\n      pairs.push(pair);\n    }\n\n    return element;\n  });\n\n  function adjustToMin(element) {\n    const isLast = element.i === pairs.length;\n    const pair = isLast ? pairs[element.i - 1] : pairs[element.i];\n\n    calculateSizes.call(pair);\n\n    const size = isLast\n      ? pair.size - element.minSize - pair[bGutterSize]\n      : element.minSize + pair[aGutterSize];\n\n    adjust.call(pair, size);\n  }\n\n  elements.forEach((element) => {\n    const computedSize = element.element[getBoundingClientRect]()[dimension];\n\n    if (computedSize < element.minSize) {\n      if (expandToMin) {\n        adjustToMin(element);\n      } else {\n        // eslint-disable-next-line no-param-reassign\n        element.minSize = computedSize;\n      }\n    }\n  });\n\n  function setSizes(newSizes) {\n    const trimmed = trimToMin(newSizes);\n    trimmed.forEach((newSize, i) => {\n      if (i > 0) {\n        const pair = pairs[i - 1];\n\n        const a = elements[pair.a];\n        const b = elements[pair.b];\n\n        a.size = trimmed[i - 1];\n        b.size = newSize;\n\n        setElementSize(a.element, a.size, pair[aGutterSize], a.i);\n        setElementSize(b.element, b.size, pair[bGutterSize], b.i);\n      }\n    });\n  }\n\n  function destroy(preserveStyles, preserveGutter) {\n    pairs.forEach((pair) => {\n      if (preserveGutter !== true) {\n        pair.parent.removeChild(pair.gutter);\n      } else {\n        pair.gutter[removeEventListener](\n          \"mousedown\",\n          pair[gutterStartDragging],\n        );\n        pair.gutter[removeEventListener](\n          \"touchstart\",\n          pair[gutterStartDragging],\n        );\n      }\n\n      if (preserveStyles !== true) {\n        const style = elementStyle(\n          dimension,\n          pair.a.size,\n          pair[aGutterSize],\n        );\n\n        Object.keys(style).forEach((prop) => {\n          elements[pair.a].element.style[prop] = \"\";\n          elements[pair.b].element.style[prop] = \"\";\n        });\n      }\n    });\n  }\n\n  return {\n    setSizes,\n    getSizes,\n    collapse(i) {\n      adjustToMin(elements[i]);\n    },\n    destroy,\n    parent,\n    pairs,\n  };\n};\n\nexport default Split;\n", "// provides the draggable space layout for elements\n// something like this:\n// ______________________\n// ----------------------\n// |   |                |\n// | 1 |       2        |\n// |   |                |\n// |   |                |\n// ----------------------\n\nimport { Mnote /* , Module */ } from \"../common/types\";\nimport { el, Elbuilder } from \"../common/elbuilder\";\nimport Split from \"../common/split\";\n\n// https://split.js.org/#/\n\nexport class LayoutModule /* implements Module */ {\n  main: HTMLElement;\n  menubar: HTMLElement;\n  sidebar: HTMLElement;\n  filetree: HTMLElement;\n  sidebarMenu: HTMLElement;\n  contents: HTMLElement;\n\n  constructor(app: Mnote) {\n    this.menubar = (() => {\n      return el(\"div\")\n        .class(\"layout-menubar\")\n        .element;\n    })();\n\n    this.sidebar = (() => {\n      this.filetree = el(\"div\")\n        .class(\"sidebar-filetree\")\n        .element;\n\n      this.sidebarMenu = el(\"div\")\n        .class(\"sidebar-menu\")\n        .element;\n\n      return el(\"div\")\n        .class(\"layout-sidebar\")\n        .children(\n          this.filetree,\n          this.sidebarMenu,\n        )\n        .element;\n    })();\n\n    this.contents = (() => {\n      return el(\"div\")\n        .class(\"layout-contents\")\n        .element;\n    })();\n\n    const container = el(\"div\")\n      .class(\"layout-container\")\n      .children(\n        this.menubar,\n        this.contents,\n      )\n      .element;\n\n    this.main = el(\"div\")\n      .class(\"layout\")\n      .children(\n        this.sidebar,\n        container,\n      )\n      .element;\n\n    Split([this.sidebar, container], {\n      gutterSize: 5,\n      sizes: [20, 80], // in %\n    });\n\n    app.element.appendChild(this.main);\n  }\n\n  mountToSidebarMenu(e: HTMLElement) {\n    this.sidebarMenu.innerHTML = \"\";\n    this.sidebarMenu.appendChild(e);\n  }\n\n  mountToFiletree(e: HTMLElement) {\n    this.filetree.innerHTML = \"\";\n    this.filetree.appendChild(e);\n  }\n\n  mountToContents(e: HTMLElement) {\n    this.contents.innerHTML = \"\";\n    this.contents.appendChild(e);\n  }\n\n  mountToMenubar(e: HTMLElement) {\n    this.menubar.innerHTML = \"\";\n    this.menubar.appendChild(e);\n  }\n}\n", "import { Mnote /* , Module */ } from \"../common/types\";\nimport { Extension } from \"./types\";\n\n// if modules are services, think of\n// extensions as the scripts\n\nexport class ExtensionsModule /* implements Module */ {\n  app: Mnote;\n  extensions: Extension[] = [];\n\n  constructor(app: Mnote) {\n    this.app = app;\n  }\n\n  add(extension: Extension) {\n    this.extensions.push(extension);\n    extension.startup();\n    return this;\n  }\n\n  remove(extension: Extension) {\n    const index = this.extensions.indexOf(extension);\n    if (index === undefined) return;\n    delete this.extensions[index];\n    extension.cleanup();\n    return this;\n  }\n}\n", "type Arguments<T> = [T] extends [(...args: infer U) => any] ? U\n  : [T] extends [void] ? []\n  : [T];\n\nexport class Emitter<E extends Record<string, Function>> {\n  protected events: Record<keyof E, Function[]> = {} as Record<\n    keyof E,\n    Function[]\n  >;\n\n  on<K extends keyof E>(event: K, listener: E[K]) {\n    let listeners = this.events[event];\n    if (!listeners) {\n      listeners = [];\n      this.events[event] = listeners;\n    }\n\n    listeners.push(listener);\n  }\n\n  remove<K extends keyof E>(event: K, listener: E[K]) {\n    const listeners = this.events[event];\n    if (!listeners) return;\n\n    const index = listeners.indexOf(listener);\n    if (index === -1) return;\n\n    delete listeners[index];\n  }\n\n  emit<K extends keyof E>(event: K, ...args: Arguments<E[K]>) {\n    const listeners = this.events[event];\n    if (!listeners) return;\n\n    listeners.forEach((listener) => setTimeout(listener, 0, ...args));\n  }\n\n  emitSync<K extends keyof E>(event: K, ...args: Arguments<E[K]>) {\n    const listeners = this.events[event];\n    if (!listeners) return;\n\n    listeners.forEach((listener) => listener(...args));\n  }\n}\n", "import { el, Elbuilder } from \"../common/elbuilder\";\nimport { Emitter } from \"../common/emitter\";\nimport { MenuItem } from \"../common/types\";\n\ntype Anchor = {\n  top: boolean;\n  left: boolean;\n};\n\ntype Position = {\n  x: number;\n  y: number;\n};\n\nexport class Menu {\n  element: HTMLElement;\n  events: Emitter<{\n    click(): void;\n  }> = new Emitter();\n  sections: MenuItem[][];\n  position: Position;\n  getAnchor: (rect: DOMRect, pos: Position) => Anchor;\n\n  constructor(\n    position: Position,\n    getAnchor: (rect: DOMRect, pos: Position) => Anchor,\n    sections: MenuItem[][],\n  ) {\n    this.getAnchor = getAnchor;\n    this.position = position;\n    this.sections = sections;\n\n    const element = el(\"div\")\n      .class(\"menu\");\n\n    const children: HTMLElement[] = [];\n\n    sections.forEach((section, i) => {\n      section.forEach((item) => {\n        const itemEl = el(\"div\")\n          .class(\"menu-item\")\n          .children(\n            el(\"div\")\n              .class(\"menu-item-left\")\n              .inner(item.name)\n              .element,\n            el(\"div\")\n              .class(\"menu-item-right\")\n              .inner(item.shortcut || \"\")\n              .element,\n          )\n          .on(\"click\", (e) => {\n            let caughtErr;\n            try {\n              item.click(e);\n            } catch (err) {\n              caughtErr = err;\n            }\n\n            // one of the listeners here will\n            // close the context menu\n            this.events.emit(\"click\");\n\n            if (caughtErr !== undefined) {\n              throw caughtErr;\n            }\n          })\n          .element;\n\n        children.push(itemEl);\n      });\n\n      if (i < sections.length - 1) {\n        children.push(\n          el(\"div\")\n            .class(\"menu-divider\")\n            .element,\n        );\n      }\n    });\n\n    this.element = element\n      .children(...children)\n      .element;\n  }\n\n  show(element: Element) {\n    // todo wrap another container just to display none?\n    element.appendChild(this.element);\n\n    const builder = new Elbuilder(this.element);\n\n    const rect = this.element.getBoundingClientRect();\n    const anchor = this.getAnchor(rect, this.position);\n\n    if (anchor.top) {\n      builder\n        .style(\"top\", this.position.y + \"px\");\n    } else {\n      builder\n        .style(\"top\", (this.position.y - rect.height) + \"px\");\n    }\n\n    if (anchor.left) {\n      builder\n        .style(\"left\", this.position.x + \"px\");\n    } else {\n      builder\n        .style(\"left\", (this.position.x - rect.width) + \"px\");\n    }\n  }\n\n  cleanup() {\n    console.log(\"menu: cleanup\", this.element, this.element.parentNode);\n    this.element = this.element.parentNode.removeChild(this.element);\n    this.events = new Emitter();\n  }\n}\n", "// utilities for DOM manipulation\n\nconst DOM_PARSER = new DOMParser();\n\n// string to html\n\nexport function toHtml(s: string): HTMLElement {\n  const doc = DOM_PARSER.parseFromString(s, \"text/html\");\n  return doc.body.childNodes[0] as HTMLElement;\n}\n\n// body freezing\n\nlet frozen: boolean = false;\n\nexport function freeze() {\n  frozen = true;\n  document.body.style[\"overflow\"] = \"hidden\";\n}\n\nexport function unfreeze() {\n  frozen = false;\n  document.body.style[\"overflow\"] = \"unset\";\n}\n\nexport function isFrozen(): boolean {\n  return frozen;\n}\n", "import { toHtml } from \"../common/util/dom\";\n\n// icons will require a stroke class and a fill class. stroke\n// classes will have the color in the stroke property and so on\n\nexport type IconsList = typeof icons;\n\nexport function createIcon(\n  name: keyof IconsList,\n  strokeClass: string,\n  fillClass: string,\n) {\n  return icons[name](strokeClass, fillClass);\n}\n\nconst icons = {\n  //\n  kebabMenu: (\n    strokeClass: string,\n    _fillClass: string,\n  ) =>\n    toHtml(`\n    <svg viewBox=\"0 0 512 512\" xmlns=\"http://www.w3.org/2000/svg\">\n      <title>ionicons-v5-f</title>\n      <circle cx=\"256\" cy=\"256\" r=\"32\" class=\"${strokeClass}\" style=\"fill:none;stroke-miterlimit:10;stroke-width:32px\"/>\n      <circle cx=\"256\" cy=\"416\" r=\"32\" class=\"${strokeClass}\" style=\"fill:none;stroke-miterlimit:10;stroke-width:32px\"/>\n      <circle cx=\"256\" cy=\"96\" r=\"32\" class=\"${strokeClass}\" style=\"fill:none;stroke-miterlimit:10;stroke-width:32px\"/>\n    </svg>\n  `),\n  //\n  add: (\n    strokeClass: string,\n    _fillClass: string,\n  ) =>\n    toHtml(`\n    <svg viewBox=\"0 0 512 512\" version=\"1.1\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns=\"http://www.w3.org/2000/svg\">\n      <defs>\n        <path d=\"M0 0L512 0L512 512L0 512L0 0Z\" id=\"path_1\" />\n        <clipPath id=\"mask_1\">\n          <use xlink:href=\"#path_1\" />\n        </clipPath>\n      </defs>\n      <g id=\"add-outline-svgrepo-com\" transform=\"translate(16 16)\">\n        <path d=\"M0 0L512 0L512 512L0 512L0 0Z\" id=\"Background\" fill=\"none\" fill-rule=\"evenodd\" stroke=\"none\" />\n        <g clip-path=\"url(#mask_1)\">\n          <path d=\"M1 0L1 288\" transform=\"translate(255 112)\" \n            class=\"${strokeClass}\" id=\"Line\" fill=\"none\" fill-rule=\"evenodd\" stroke-width=\"32\" stroke-linecap=\"round\" stroke-linejoin=\"round\" />\n          <path d=\"M288 1L0 1\" transform=\"translate(112 255)\" \n            class=\"${strokeClass}\" id=\"Line\" fill=\"none\" fill-rule=\"evenodd\" stroke-width=\"32\" stroke-linecap=\"round\" stroke-linejoin=\"round\" />\n        </g>\n      </g>\n    </svg>\n  `),\n};\n", "import { MenuItem, Mnote /* , Module */ } from \"../common/types\";\nimport { LayoutModule } from \"./layout\";\nimport { el } from \"../common/elbuilder\";\nimport { Menu } from \"../components/menu\";\nimport { LoggingModule } from \"./logging\";\nimport { createIcon } from \"../components/icons\";\n\n// https://quilljs.com/docs/modules/toolbar/\n\ntype SectionReducer = () => MenuItem[];\n\nexport class MenubarModule /* implements Module */ {\n  layout: LayoutModule;\n  logging: LoggingModule;\n\n  element: HTMLElement;\n  left: HTMLElement;\n  right: HTMLElement;\n  app: Mnote;\n\n  menuToggle: HTMLElement;\n  menuButtons: MenuItem[][] = [\n    [\n      {\n        name: \"hey\",\n        click: () => {\n          this.logging.info(\"menubar: menu item click\");\n        },\n      },\n    ],\n  ];\n  menuReducers: SectionReducer[] = [];\n  menuCurrent?: Menu;\n\n  constructor(app: Mnote) {\n    this.app = app;\n\n    this.left = el(\"div\")\n      .class(\"menubar-left\")\n      .element;\n\n    this.menuToggle = el(\"div\")\n      .class(\"menubar-menu-toggle\")\n      .children(\n        el(\"div\")\n          .class(\"menubar-icon\")\n          .children(\n            createIcon(\"kebabMenu\", \"stroke\", \"fill\"),\n          )\n          .element,\n      )\n      .on(\"click\", () => {\n        if (this.menuCurrent) {\n          this.hideMenu();\n        } else {\n          this.showMenu();\n        }\n      })\n      .element;\n\n    this.right = el(\"div\")\n      .class(\"menubar-right\")\n      .children(this.menuToggle)\n      .element;\n\n    this.element = el(\"div\")\n      .class(\"menubar\")\n      .children(\n        this.left,\n        this.right,\n      )\n      .element;\n\n    this.logging = app.modules.logging as LoggingModule;\n    this.layout = app.modules.layout as LayoutModule;\n    this.layout.mountToMenubar(this.element);\n\n    // close the menu when the user clicks somewhere else\n    document.addEventListener(\"mousedown\", (e: MouseEvent) => {\n      this.logging.info(\"menubar: menu listener for external mousedown\");\n\n      if (!this.menuCurrent) return;\n      const mouseoverEls = document.elementsFromPoint(e.pageX, e.pageY);\n\n      if (mouseoverEls.indexOf(this.menuCurrent.element) === -1) {\n        this.hideMenu();\n      }\n    });\n  }\n\n  showMenu() {\n    this.logging.info(\"menubar: showMenu\");\n\n    this.hideMenu();\n\n    const buttons = this.menuReducers.map((reducer) => {\n      const section = reducer();\n      if (section) return section;\n    });\n\n    if (buttons.length === 0) return;\n\n    const menu = new Menu({\n      x: this.menuToggle.getBoundingClientRect().right,\n      y: this.element.getBoundingClientRect().bottom,\n    }, () => {\n      return { top: true, left: false };\n    }, buttons);\n\n    this.menuCurrent = menu;\n\n    menu.events.on(\"click\", () => {\n      this.logging.info(\"menubar: menu event on click\");\n      this.hideMenu();\n    });\n\n    menu.show(this.app.element);\n  }\n\n  hideMenu() {\n    this.logging.info(\"menubar: hideMenu\", this.menuCurrent);\n\n    if (this.menuCurrent) {\n      this.menuCurrent.cleanup();\n      delete this.menuCurrent;\n    }\n  }\n\n  addSectionReducer(reducer: SectionReducer) {\n    this.menuReducers.push(reducer);\n  }\n\n  setMenubarText(text: string) {\n    this.left.innerText = text;\n  }\n}\n", "// https://code.visualstudio.com/api/references/vscode-api#window.showInformationMessage\n// https://vercel.com/design/modal\n\nimport { el } from \"../common/elbuilder\";\nimport { freeze, unfreeze } from \"../common/util/dom\";\nimport { ModalButton } from \"../modules/types\";\n\nexport class Modal {\n  container: Element;\n  message: string;\n  buttons: ModalButton[];\n\n  constructor(opts: {\n    container: Element;\n    message: string;\n    buttons: ModalButton[];\n  }) {\n    this.message = opts.message;\n    this.container = opts.container;\n    this.buttons = opts.buttons;\n  }\n\n  prompt(): Promise<string> {\n    const buttonEls: HTMLElement[] = [];\n\n    this.buttons.forEach((buttonData) => {\n      const button = el(\"div\")\n        .class(\"modal-button\")\n        .class(buttonData.kind)\n        .inner(buttonData.text)\n        .attr(\"modal-command\", buttonData.command)\n        .element;\n\n      buttonEls.push(button);\n    });\n\n    const buttons = el(\"div\")\n      .class(\"modal-buttons\")\n      .children(...buttonEls)\n      .element;\n\n    const text = el(\"div\")\n      .class(\"modal-text\")\n      .inner(this.message)\n      .element;\n\n    const menu = el(\"div\")\n      .class(\"modal\")\n      .children(\n        text,\n        buttons,\n      )\n      .element;\n\n    const overlay = el(\"div\")\n      .class(\"modal-overlay\")\n      .children(menu)\n      .element;\n\n    freeze();\n    this.container.appendChild(overlay);\n\n    return new Promise((resolve) => {\n      const listeners: Map<HTMLElement, () => void> = new Map();\n\n      buttonEls.forEach((element) => {\n        const command = element.getAttribute(\"modal-command\");\n\n        let listener: () => void;\n        listener = () => {\n          for (const [k, v] of listeners.entries()) {\n            k.removeEventListener(\"click\", v);\n          }\n\n          overlay.parentNode.removeChild(overlay);\n          unfreeze();\n          resolve(command);\n        };\n\n        listeners.set(element, listener);\n        element.addEventListener(\"click\", listener);\n      });\n    });\n  }\n}\n", "const EXTENSION_REGEX = /(\\.[^.]+)[\\\\/]?$/;\nconst NAME_REGEX = /([^\\\\/]+)[\\\\/]?$/;\nconst PARENT_REGEX = /(.+)[\\\\/][^\\\\/]+[\\\\/]?$/;\n\n/** returns the entire path if not found */\nexport function getPathName(path: string): string {\n  const matches = path.match(NAME_REGEX);\n  if (matches) return matches[1];\n  return path;\n}\n\n/** returns a blank string if not found */\nexport function getPathExtension(path: string): string {\n  const matches = path.match(EXTENSION_REGEX);\n  if (matches) return matches[1];\n  return \"\";\n}\n\n/** returns the parent directory path */\nexport function getPathParent(path: string): string {\n  const matches = path.match(PARENT_REGEX);\n  if (matches) return matches[1];\n  return path;\n}\n", "export const strings = {\n  noStartPath: (startPath: string) =>\n    `Oops - we couldn't find the path \"${startPath}\". Try relaunching the app.`,\n  confirmSaveBeforeClose: () =>\n    \"Would you like to save the current document before closing?\",\n};\n", "import { MenuItem, Mnote /* , Module */ } from \"../common/types\";\nimport { el } from \"../common/elbuilder\";\nimport { LayoutModule } from \"./layout\";\nimport {\n  DocInfo,\n  Editor,\n  EditorContext,\n  EditorInfo,\n  EditorProvider,\n  ModalButton,\n} from \"./types\";\nimport { MenubarModule } from \"./menubar\";\nimport { FSModule } from \"./fs\";\nimport { LoggingModule } from \"./logging\";\nimport { Modal } from \"../components/modal\";\nimport { FiletreeModule } from \"./filetree\";\nimport { Emitter } from \"../common/emitter\";\nimport { getPathName } from \"../common/util/path\";\nimport { SystemModule } from \"./system\";\nimport { strings } from \"../common/strings\";\nimport { Menu } from \"../components/menu\";\nimport { SidemenuModule } from \"./sidemenu\";\nimport { InputModule } from \"./input\";\n\n// https://code.visualstudio.com/api/extension-guides/custom-editors#custom-editor-api-basics\n\n// todo: a nicer placeholder\nconst nothingHere = el(\"div\")\n  .inner(\"...\")\n  .element;\n\n// editors keep the contents in their stae\n// this module communicates between all the other parts of the app, so\n// no other component can ever access the editor object without going\n// here\n\n/* outline ( annotations can be found in the actual code )\n\nexport class EditorsModule {\n  element: HTMLElement;\n  events: Emitter<\n  confirmCloseModal: Modal;\n\n  editors: EditorInfo[] = [];\n  editorKinds: Record<string, EditorInfo> = {};\n\n  currentEditor?: Editor;\n  currentDocument?: DocInfo;\n\n  constructor(app: Mnote)\n\n  protected hookToSidebarMenu() {\n  protected hookToMenubar() {\n  protected hookToInputs() {\n  protected hookToFiletree() {\n\n  registerEditor(kind: string, provider: EditorProvider) {\n  protected setCurrentDocument(doc?: DocInfo) {\n  async open(path?: string) {\n  async newEditor(kind: string) {d)\n  async saveAs(): Promise<boolean> {\n  async save(): Promise<boolean> {\n  async close(): Promise<boolean> {\n  protected async cleanup() {\n  protected clear() {\n  protected makeContext(): EditorContext {\n  protected async load(path: string) {\n} */\n\nexport class EditorsModule /* implements Module */ {\n  element: HTMLElement;\n  app: Mnote;\n  menubar: MenubarModule;\n  fs: FSModule;\n  system: SystemModule;\n  input: InputModule;\n  logging: LoggingModule;\n  sidemenu: SidemenuModule;\n  filetree: FiletreeModule;\n\n  events: Emitter<{\n    docSavedChanged: (doc: DocInfo) => void;\n    docSet?: (doc: DocInfo) => void;\n  }> = new Emitter();\n\n  confirmCloseModal: Modal;\n\n  // collection of editors, thier providers and their configurations\n  // providers return an editor if it should open a path\n  editors: EditorInfo[] = [];\n  editorKinds: Record<string, EditorInfo> = {};\n\n  currentEditor?: Editor;\n  currentDocument?: DocInfo;\n\n  constructor(app: Mnote) {\n    this.app = app;\n    this.menubar = app.modules.menubar as MenubarModule;\n    this.fs = app.modules.fs as FSModule;\n    this.system = app.modules.system as SystemModule;\n    this.input = app.modules.input as InputModule;\n    this.logging = app.modules.logging as LoggingModule;\n    this.sidemenu = app.modules.sidemenu as SidemenuModule;\n    this.filetree = app.modules.filetree as FiletreeModule;\n\n    this.confirmCloseModal = new Modal({\n      container: this.app.element,\n      message: strings.confirmSaveBeforeClose(),\n      buttons: confirmCloseModalButtons, // at the bottom of this file to avoid clutter\n    });\n\n    this.element = el(\"div\")\n      .class(\"editor-container\")\n      .element;\n\n    (app.modules.layout as LayoutModule).mountToContents(this.element);\n\n    this.element.appendChild(nothingHere);\n\n    // hook methods to the rest of the app\n\n    this.hookToSidebarMenu();\n    this.hookToMenubar();\n    this.hookToInputs();\n    this.hookToFiletree();\n  }\n\n  protected hookToSidebarMenu() {\n    // the \"New File\" button and menu\n    const button = this.sidemenu.createButton(\"add\");\n    let menu: Menu | undefined;\n\n    const hideMenu = () => {\n      if (menu) {\n        menu.cleanup();\n        menu = undefined;\n      }\n    };\n\n    const getSections: () => MenuItem[] | undefined = () => {\n      const result: MenuItem[] = [];\n      for (const i in this.editors) {\n        const editorInfo = this.editors[i];\n        if (!editorInfo.hideFromNewMenu) {\n          result.push({\n            name: editorInfo.kind,\n            click: () => {\n              this.newEditor(editorInfo.kind);\n              hideMenu();\n            },\n          });\n        }\n      }\n      return result.length > 0 && result;\n    };\n\n    const showMenu = () => {\n      hideMenu();\n\n      const buttonRect = button.getBoundingClientRect();\n\n      menu = new Menu(\n        { x: buttonRect.right, y: buttonRect.top },\n        () => ({ top: false, left: false }),\n        [getSections()],\n      );\n\n      menu.show(this.app.element);\n    };\n\n    button.addEventListener(\"click\", showMenu);\n    document.addEventListener(\"mousedown\", (e) => {\n      if (menu) {\n        const els = document.elementsFromPoint(e.pageX, e.pageY);\n        if (els.indexOf(menu.element) === -1) hideMenu();\n      }\n    });\n\n    this.sidemenu.addButton(button);\n  }\n\n  protected hookToMenubar() {\n    // update the menubar title\n    const updateMenubarTitle = (doc?: DocInfo) => {\n      if (doc) {\n        this.menubar.setMenubarText(\n          (doc.saved ? \"\" : \"*\") + doc.name,\n        );\n      } else {\n        this.menubar.setMenubarText(\"\");\n      }\n    };\n\n    this.events.on(\"docSavedChanged\", updateMenubarTitle);\n    this.events.on(\"docSet\", updateMenubarTitle);\n\n    const cmdOrCtrl = this.system.USES_CMD ? \"Cmd\" : \"Ctrl\";\n    this.logging.info(\"command or ctrl?\", cmdOrCtrl);\n\n    // menubar reducer\n    const menubarReducer = () => {\n      const buttons = [];\n\n      buttons.push({\n        name: \"Open\",\n        shortcut: cmdOrCtrl + \"+O\",\n        click: () => {\n          this.open();\n        },\n      });\n\n      if (this.currentDocument) {\n        buttons.push({\n          name: \"Save\",\n          shortcut: cmdOrCtrl + \"+S\",\n          click: () => {\n            this.save();\n          },\n        });\n\n        buttons.push({\n          name: \"Save As\",\n          shortcut: cmdOrCtrl + \"+Shift+S\",\n          click: () => {\n            this.saveAs();\n          },\n        });\n\n        buttons.push({\n          name: \"Close\",\n          shortcut: cmdOrCtrl + \"+W\",\n          click: () => {\n            this.close();\n          },\n        });\n      }\n\n      return buttons;\n    };\n\n    this.menubar.addSectionReducer(menubarReducer);\n  }\n\n  protected hookToInputs() {\n    // hotkeys\n    this.input.registerShortcut([\"command+o\", \"ctrl+o\"], (e) => {\n      this.logging.info(\"editor keys: ctrl o\");\n      e.preventDefault();\n      this.open();\n    });\n\n    this.input.registerShortcut([\"command+s\", \"ctrl+s\"], (e) => {\n      this.logging.info(\"editor keys: ctrl s\");\n      if (this.currentDocument) {\n        e.preventDefault();\n        this.save();\n      }\n    });\n\n    this.input.registerShortcut([\"command+shift+s\", \"ctrl+shift+s\"], (e) => {\n      this.logging.info(\"editor keys: ctrl shift s\");\n      if (this.currentDocument) {\n        e.preventDefault();\n        this.saveAs();\n      }\n    });\n\n    this.input.registerShortcut([\"command+w\", \"ctrl+w\"], (e) => {\n      this.logging.info(\"editor keys: ctrl w\");\n      if (this.currentDocument) {\n        e.preventDefault();\n        this.close();\n      }\n    });\n  }\n\n  protected hookToFiletree() {\n    // when filetree selects from startPath\n    if (this.filetree.selectedFile) {\n      this.open(this.filetree.selectedFile).then(() => {\n        this.logging.info(\n          \"editors: loaded start file path from filetree\",\n          this.filetree.selectedFile,\n        );\n      });\n    }\n\n    // when a filetree file gets selected\n    this.filetree.events.on(\"selected\", (path: string) => {\n      this.logging.info(\"editors: load path\", path);\n      this.open(path).then(() => {\n        this.logging.info(\"editors: loaded path\", path);\n      });\n    });\n  }\n\n  /** Register an editor provider */\n  registerEditor(opts: EditorInfo) {\n    if (this.editorKinds[opts.kind]) {\n      throw new Error(`Editor of kind \"${opts.kind}\" already exists!`);\n    }\n    this.editorKinds[opts.kind] = opts;\n    this.editors.push(opts);\n  }\n\n  // wrapper so that we can hook events\n  protected setCurrentDocument(doc?: DocInfo) {\n    this.currentDocument = doc;\n    this.events.emit(\"docSet\", doc);\n  }\n\n  // open button\n  async open(path?: string) {\n    // use fs.dialogOpen\n    const willClose = await this.close();\n    if (!willClose) {\n      return;\n    }\n\n    if (!path) {\n      const maybePath = await this.fs.dialogOpen({\n        directory: false,\n      });\n      if (!maybePath) return;\n    }\n\n    await this.load(path);\n  }\n\n  // create new button\n  async newEditor(kind: string) {\n    this.logging.info(\"new editor\");\n\n    const editorInfo = this.editorKinds[kind];\n    if (!editorInfo) {\n      throw new Error(`Editor of kind \"${kind}\" does not exist!`);\n    }\n\n    const willClose = await this.close();\n    this.logging.info(\"will close?\", willClose);\n    if (!willClose) {\n      return;\n    }\n\n    this.clear();\n\n    this.setCurrentDocument({\n      name: \"Untitled\",\n      // no path\n      saved: false,\n    });\n\n    const editor = editorInfo.provider.createNewEditor();\n    this.currentEditor = editor;\n    await editor.startup(this.element, this.makeContext());\n  }\n\n  // DRY for saving with a modal on error\n  protected async trySaveEditor(): Promise<boolean> {\n    try {\n      await this.currentEditor.save(this.currentDocument.path);\n      return true;\n    } catch (e) {\n      new Modal({\n        container: this.element,\n        message: `An error occurred while saving: ${e}`,\n        buttons: [{\n          kind: \"emphasis\",\n          text: \"OK\",\n          command: \"\",\n        }],\n      }).prompt();\n      return false;\n    }\n  }\n\n  // prompt a save dialog\n  // returns a success boolean (whether the user cancelled)\n  async saveAs(): Promise<boolean> {\n    this.logging.info(\"save as\");\n    if (!this.currentEditor || !this.currentDocument) return true;\n\n    const newPath = await this.fs.dialogSave({\n      // initialPath: dir,\n    });\n\n    this.logging.info(\"new path\", newPath);\n    if (!newPath) return false;\n\n    const success = await this.trySaveEditor();\n    this.logging.info(\"save editor success\", success);\n    if (!success) return false;\n\n    this.setCurrentDocument({\n      path: newPath,\n      name: getPathName(newPath),\n      saved: true,\n    });\n\n    return true;\n  }\n\n  // directly save the current document, or prompt if it doesn't have a path\n  // returns a success boolean (whether the user cancelled)\n  async save(): Promise<boolean> {\n    this.logging.info(\"save\");\n    if (!this.currentEditor || !this.currentDocument) return true;\n\n    if (this.currentDocument.path) {\n      const success = await this.trySaveEditor();\n      if (!success) {\n        return false;\n      }\n    } else {\n      // prompt save\n      const success = await this.saveAs();\n      if (!success) {\n        return false;\n      }\n    }\n\n    this.currentDocument.saved = true;\n    this.events.emit(\"docSavedChanged\", this.currentDocument);\n    return true;\n  }\n\n  // close button\n  // returns a boolean whether it;s confirmed and anyone pending can\n  // continue\n  async close(): Promise<boolean> {\n    this.logging.info(\"close\", this.currentDocument, this.currentEditor);\n    if (!this.currentEditor || !this.currentDocument) return true;\n    this.logging.info(\"close: has editor and document\");\n\n    if (!this.currentDocument.path) {\n      this.logging.info(\"close: doc has no path\");\n      // no path, therefore unsaved\n      // popup save as\n      // if cancelled, abort\n      if (await this.save()) {\n        this.logging.info(\"close: saved\");\n        await this.cleanup();\n        return true;\n      } else {\n        this.logging.info(\"close: unsaved\");\n        return false;\n      }\n    } else if (!this.currentDocument.saved) {\n      this.logging.info(\"close: doc has path, but not saved\");\n      // has path, but unsaved\n      // would you like to save?\n\n      switch (await this.confirmCloseModal.prompt()) {\n        case \"save\":\n          this.logging.info(\"close modal: save\");\n          if (await this.save()) {\n            await this.cleanup();\n            return true;\n          } else {\n            return false;\n          }\n        case \"cancel\":\n          this.logging.info(\"close modal: cancel\");\n          return false;\n        case \"dontsave\":\n          this.logging.info(\"close modal: donstave\");\n          await this.cleanup();\n          return true;\n      }\n    } else {\n      this.logging.info(\"close: doc has path, is saved\");\n      // has path, saved\n      await this.cleanup();\n      return true;\n    }\n  }\n\n  // cleanup the current document, the current editor,\n  // and the container element, append an empty placeholder\n  protected async cleanup() {\n    this.logging.info(\"cleanup\");\n    if (this.currentEditor) {\n      await this.currentEditor.cleanup();\n      delete this.currentEditor;\n    }\n    this.clear();\n    this.element.appendChild(nothingHere);\n    if (this.currentDocument) {\n      this.setCurrentDocument(undefined);\n    }\n  }\n\n  // force clear element\n  protected clear() {\n    this.element.innerHTML = \"\";\n  }\n\n  // make the api publicly available to\n  // editors\n  protected makeContext(): EditorContext {\n    return {\n      updateEdited: () => {\n        if (this.currentDocument) {\n          this.currentDocument.saved = false;\n          this.events.emit(\"docSavedChanged\", this.currentDocument);\n        }\n      },\n      getDocument: () => this.currentDocument,\n      setDocument: (doc: DocInfo) => {\n        this.setCurrentDocument(doc);\n      },\n    };\n  }\n\n  // try and find an editor that will open a path and start it up\n  // will always find an editor, defaults to plaintext\n  // takes a path, but doesn't read , only passes it to the editor\n  protected async load(path: string) {\n    // patj guaranteed exists\n\n    await this.cleanup();\n    this.clear();\n\n    let selectedEditor: Editor;\n\n    // last added runs first, assuming it's more selective\n    // as the plaintext (which accepts all) is first\n    for (let i = this.editors.length - 1; i > -1; i--) {\n      const provider = this.editors[i].provider;\n      const editor = provider.tryGetEditor(path);\n      if (editor) {\n        selectedEditor = editor;\n        break;\n      }\n    }\n\n    if (selectedEditor) {\n      this.setCurrentDocument({\n        name: getPathName(path),\n        saved: true,\n        path,\n      });\n\n      this.currentEditor = selectedEditor;\n      this.element.innerHTML = \"\";\n      await selectedEditor.startup(this.element, this.makeContext()); //todo: handle err\n      await selectedEditor.load(this.currentDocument.path);\n    }\n  }\n}\n\nconst confirmCloseModalButtons: ModalButton[] = [\n  {\n    kind: \"normal\",\n    text: \"Cancel\",\n    command: \"cancel\",\n  },\n  {\n    kind: \"normal\",\n    text: \"Don't save\",\n    command: \"dontsave\",\n  },\n  {\n    kind: \"emphasis\",\n    text: \"Save\",\n    command: \"save\",\n  },\n];\n", "import {\n  FileItem,\n  FileItemWithChildren,\n  FsInteropModule,\n  Mnote,\n} from \"../common/types\";\n\n// the interop module\n// todo: mock\n// https://tauri.studio/en/docs/api/js/modules/fs\n\nexport class FSModule implements FsInteropModule {\n  protected fs?: FsInteropModule;\n\n  constructor(fs?: FsInteropModule) {\n    if (fs) this.fs = fs;\n  }\n\n  async writeTextFile(path: string, contents: string): Promise<void> {\n    if (this.fs) {\n      return this.fs.writeTextFile(path, contents);\n    }\n  }\n\n  async readTextFile(path: string): Promise<string> {\n    if (this.fs) {\n      return this.fs.readTextFile(path);\n    }\n    return \".\";\n  }\n\n  async readDir(path: string): Promise<FileItemWithChildren> {\n    if (this.fs) {\n      const entries = this.fs.readDir(path);\n      return entries;\n    }\n    return {\n      path: \"TEMP\",\n      children: [],\n    };\n  }\n\n  async isFile(path: string): Promise<boolean> {\n    if (this.fs) {\n      return this.fs.isFile(path);\n    }\n    return false;\n  }\n\n  async isDir(path: string): Promise<boolean> {\n    if (this.fs) {\n      return this.fs.isDir(path);\n    }\n    return false;\n  }\n\n  async dialogOpen(opts: {\n    initialPath?: string;\n    extensions?: string[];\n    directory: boolean;\n  }): Promise<string | void> {\n    if (this.fs) {\n      return this.fs.dialogOpen(opts);\n    }\n  }\n\n  async dialogOpenMultiple(opts: {\n    initialPath?: string;\n    extensions?: string[];\n    directory: boolean;\n  }): Promise<string[] | void> {\n    if (this.fs) {\n      return this.fs.dialogOpenMultiple(opts);\n    }\n  }\n\n  async dialogSave(opts: {\n    initialPath?: string;\n    extensions?: string[];\n  }): Promise<string | void> {\n    if (this.fs) {\n      return this.fs.dialogSave(opts);\n    }\n  }\n\n  async getConfigDir(): Promise<string> {\n    if (this.fs) {\n      return this.fs.getConfigDir();\n    }\n    return \".\";\n  }\n\n  async getCurrentDir(): Promise<string> {\n    if (this.fs) {\n      return this.fs.getCurrentDir();\n    }\n    return \".\";\n  }\n\n  joinPath(items: string[]): string {\n    if (this.fs) {\n      return this.fs.joinPath(items);\n    }\n    return items.join(\"/\");\n  }\n\n  async watchInit(path: string) {\n    if (this.fs) {\n      return this.fs.watchInit(path);\n    }\n  }\n\n  onWatchEvent(handler: () => void | Promise<void>) {\n    if (this.fs) {\n      return this.fs.onWatchEvent(handler);\n    }\n  }\n}\n", "import { Mnote /* , Module */ } from \"../common/types\";\n\nexport class LoggingModule /* implements Module */ {\n  enabled: boolean = true;\n\n  constructor(app: Mnote) {\n    if (app.options.isProduction) {\n      this.enabled = false;\n      this.info = () => {};\n    }\n  }\n\n  info(...messages: unknown[]) {\n    if (this.enabled) {\n      console.log(\"[INFO]\", ...messages);\n    }\n  }\n\n  err(...messages: unknown[]) {\n    console.error(\"[ERR]\", ...messages);\n  }\n\n  warn(...messages: unknown[]) {\n    console.warn(\"[WARN]\", ...messages);\n  }\n}\n", "import { MenuItem, Mnote } from \"../common/types\";\nimport { Menu } from \"../components/menu\";\nimport { LayoutModule } from \"./layout\";\nimport { Context } from \"./types\";\n\n/* {\n  name: \"Copy\",\n  shortcut: \"CTRL+1\",\n  click: () => {},\n} */\n\ntype SectionReducer = (ctx: Context) => MenuItem[] | void;\n\nexport class CtxmenuModule {\n  ctxmenu: ContextMenu;\n  app: Mnote;\n  reducers: SectionReducer[] = [];\n\n  constructor(app: Mnote) {\n    this.app = app;\n\n    const getSections = (ctx: Context) => {\n      const sections = [];\n      this.reducers.forEach((reducer) => {\n        const section = reducer(ctx);\n        if (section) sections.push(section);\n      });\n      return sections;\n    };\n\n    this.ctxmenu = new ContextMenu(\n      app.element,\n      [(app.modules.layout as LayoutModule).contents],\n      getSections,\n    );\n  }\n\n  addSectionReducer(reducer: SectionReducer) {\n    this.reducers.push(reducer);\n  }\n}\n\nexport class ContextMenu {\n  cleanup: () => void;\n  activeMenu?: Menu;\n  blacklist: Set<Element>;\n\n  constructor(\n    element: Element,\n    blacklist: Element[],\n    getSections: (context: Context) => MenuItem[][],\n  ) {\n    this.blacklist = new Set(blacklist);\n\n    const onContextMenu = (e: MouseEvent) => {\n      for (const elm of document.elementsFromPoint(e.pageX, e.pageY)) {\n        if (this.blacklist.has(elm)) {\n          delete this.activeMenu; //?\n          return;\n        }\n      }\n\n      e.stopPropagation();\n      e.preventDefault();\n\n      const context: Context = {\n        pageX: e.pageX,\n        pageY: e.pageY,\n        element: document.elementFromPoint(e.pageX, e.pageY),\n      };\n\n      const sections = getSections(context);\n\n      if (sections.length < 1) {\n        delete this.activeMenu;\n        return;\n      }\n\n      if (this.activeMenu) {\n        this.activeMenu.cleanup();\n        delete this.activeMenu;\n      }\n\n      this.activeMenu = new Menu(\n        {\n          x: e.pageX,\n          y: e.pageY,\n        },\n        (rect: DOMRect /*, pos */) => {\n          return {\n            top: e.pageY + rect.height < innerHeight,\n            left: e.pageX + rect.width < innerWidth,\n          };\n        },\n        sections,\n      );\n\n      this.activeMenu.events.on(\"click\", () => {\n        if (this.activeMenu) {\n          this.activeMenu.cleanup();\n          delete this.activeMenu;\n        }\n      });\n\n      this.activeMenu.show(element);\n    };\n\n    const onClick = (e: MouseEvent) => {\n      console.log(\"somewhereelse click\");\n\n      if (!this.activeMenu) return;\n\n      const mouseoverEls = document.elementsFromPoint(e.pageX, e.pageY);\n      if (mouseoverEls.indexOf(this.activeMenu.element) === -1) {\n        this.activeMenu.cleanup();\n        delete this.activeMenu;\n      }\n    };\n\n    document.addEventListener(\"contextmenu\", onContextMenu);\n    document.addEventListener(\"mousedown\", onClick);\n\n    this.cleanup = () => {\n      document.removeEventListener(\"contextmenu\", onContextMenu);\n      document.removeEventListener(\"mousedown\", onClick);\n    };\n  }\n\n  addBlacklist(e: Element) {\n    this.blacklist.add(e);\n  }\n}\n", "import { SystemInteropModule } from \"../common/types\";\n\nexport class SystemModule implements SystemInteropModule {\n  protected system?: SystemInteropModule;\n\n  USES_CMD: boolean;\n\n  constructor(system: SystemInteropModule) {\n    this.system = system;\n    this.USES_CMD = system ? system.USES_CMD : false; // todo: can we use a browser api?\n  }\n\n  // todo: move some fs items to system?\n}\n", "import { el } from \"../common/elbuilder\";\nimport { Mnote } from \"../common/types\";\nimport { createIcon, IconsList } from \"../components/icons\";\nimport { LayoutModule } from \"./layout\";\n\nexport class SidemenuModule {\n  layout: LayoutModule;\n  element: HTMLElement;\n\n  constructor(app: Mnote) {\n    this.layout = app.modules.layout as LayoutModule;\n    this.element = el(\"div\")\n      .class(\"sidemenu-main\")\n      .element;\n\n    this.layout.mountToSidebarMenu(this.element);\n  }\n\n  createButton(iconName: keyof IconsList): HTMLElement {\n    return el(\"div\")\n      .class(\"sidemenu-button\")\n      .children(\n        createIcon(iconName, \"stroke\", \"fill\"),\n      )\n      .element;\n  }\n\n  addButton(button: HTMLElement) {\n    this.element.appendChild(button);\n  }\n}\n", "export const EMPTY_OBJ = {};\nexport const EMPTY_ARR = [];\nexport const IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;\n", "import { EMPTY_ARR } from \"./constants\";\n\n/**\n * Assign properties from `props` to `obj`\n * @template O, P The obj and props types\n * @param {O} obj The object to copy properties to\n * @param {P} props The object to copy properties from\n * @returns {O & P}\n */\nexport function assign(obj, props) {\n\t// @ts-ignore We change the type of `obj` to be `O & P`\n\tfor (let i in props) obj[i] = props[i];\n\treturn /** @type {O & P} */ (obj);\n}\n\n/**\n * Remove a child node from its parent if attached. This is a workaround for\n * IE11 which doesn't support `Element.prototype.remove()`. Using this function\n * is smaller than including a dedicated polyfill.\n * @param {Node} node The node to remove\n */\nexport function removeNode(node) {\n\tlet parentNode = node.parentNode;\n\tif (parentNode) parentNode.removeChild(node);\n}\n\nexport const slice = EMPTY_ARR.slice;\n", "import { _catchError } from './diff/catch-error';\n\n/**\n * The `option` object can potentially contain callback functions\n * that are called during various stages of our renderer. This is the\n * foundation on which all our addons like `preact/debug`, `preact/compat`,\n * and `preact/hooks` are based on. See the `Options` type in `internal.d.ts`\n * for a full list of available option hooks (most editors/IDEs allow you to\n * ctrl+click or cmd+click on mac the type definition below).\n * @type {import('./internal').Options}\n */\nconst options = {\n\t_catchError\n};\n\nexport default options;\n", "import { slice } from './util';\nimport options from './options';\n\nlet vnodeId = 0;\n\n/**\n * Create an virtual node (used for JSX)\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component\n * constructor for this virtual node\n * @param {object | null | undefined} [props] The properties of the virtual node\n * @param {Array<import('.').ComponentChildren>} [children] The children of the virtual node\n * @returns {import('./internal').VNode}\n */\nexport function createElement(type, props, children) {\n\tlet normalizedProps = {},\n\t\tkey,\n\t\tref,\n\t\ti;\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse normalizedProps[i] = props[i];\n\t}\n\n\tif (arguments.length > 2) {\n\t\tnormalizedProps.children =\n\t\t\targuments.length > 3 ? slice.call(arguments, 2) : children;\n\t}\n\n\t// If a Component VNode, check for and apply defaultProps\n\t// Note: type may be undefined in development, must never error here.\n\tif (typeof type == 'function' && type.defaultProps != null) {\n\t\tfor (i in type.defaultProps) {\n\t\t\tif (normalizedProps[i] === undefined) {\n\t\t\t\tnormalizedProps[i] = type.defaultProps[i];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn createVNode(type, normalizedProps, key, ref, null);\n}\n\n/**\n * Create a VNode (used internally by Preact)\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component\n * Constructor for this virtual node\n * @param {object | string | number | null} props The properties of this virtual node.\n * If this virtual node represents a text node, this is the text of the node (string or number).\n * @param {string | number | null} key The key for this virtual node, used when\n * diffing it against its children\n * @param {import('./internal').VNode[\"ref\"]} ref The ref property that will\n * receive a reference to its created child\n * @returns {import('./internal').VNode}\n */\nexport function createVNode(type, props, key, ref, original) {\n\t// V8 seems to be better at detecting type shapes if the object is allocated from the same call site\n\t// Do not inline into createElement and coerceToVNode!\n\tconst vnode = {\n\t\ttype,\n\t\tprops,\n\t\tkey,\n\t\tref,\n\t\t_children: null,\n\t\t_parent: null,\n\t\t_depth: 0,\n\t\t_dom: null,\n\t\t// _nextDom must be initialized to undefined b/c it will eventually\n\t\t// be set to dom.nextSibling which can return `null` and it is important\n\t\t// to be able to distinguish between an uninitialized _nextDom and\n\t\t// a _nextDom that has been set to `null`\n\t\t_nextDom: undefined,\n\t\t_component: null,\n\t\t_hydrating: null,\n\t\tconstructor: undefined,\n\t\t_original: original == null ? ++vnodeId : original\n\t};\n\n\tif (options.vnode != null) options.vnode(vnode);\n\n\treturn vnode;\n}\n\nexport function createRef() {\n\treturn { current: null };\n}\n\nexport function Fragment(props) {\n\treturn props.children;\n}\n\n/**\n * Check if a the argument is a valid Preact VNode.\n * @param {*} vnode\n * @returns {vnode is import('./internal').VNode}\n */\nexport const isValidElement = vnode =>\n\tvnode != null && vnode.constructor === undefined;\n", "import { assign } from './util';\nimport { diff, commitRoot } from './diff/index';\nimport options from './options';\nimport { Fragment } from './create-element';\n\n/**\n * Base Component class. Provides `setState()` and `forceUpdate()`, which\n * trigger rendering\n * @param {object} props The initial component props\n * @param {object} context The initial context from parent components'\n * getChildContext\n */\nexport function Component(props, context) {\n\tthis.props = props;\n\tthis.context = context;\n}\n\n/**\n * Update component state and schedule a re-render.\n * @this {import('./internal').Component}\n * @param {object | ((s: object, p: object) => object)} update A hash of state\n * properties to update with new values or a function that given the current\n * state and props returns a new partial state\n * @param {() => void} [callback] A function to be called once component state is\n * updated\n */\nComponent.prototype.setState = function(update, callback) {\n\t// only clone state when copying to nextState the first time.\n\tlet s;\n\tif (this._nextState != null && this._nextState !== this.state) {\n\t\ts = this._nextState;\n\t} else {\n\t\ts = this._nextState = assign({}, this.state);\n\t}\n\n\tif (typeof update == 'function') {\n\t\t// Some libraries like `immer` mark the current state as readonly,\n\t\t// preventing us from mutating it, so we need to clone it. See #2716\n\t\tupdate = update(assign({}, s), this.props);\n\t}\n\n\tif (update) {\n\t\tassign(s, update);\n\t}\n\n\t// Skip update if updater function returned null\n\tif (update == null) return;\n\n\tif (this._vnode) {\n\t\tif (callback) this._renderCallbacks.push(callback);\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Immediately perform a synchronous re-render of the component\n * @this {import('./internal').Component}\n * @param {() => void} [callback] A function to be called after component is\n * re-rendered\n */\nComponent.prototype.forceUpdate = function(callback) {\n\tif (this._vnode) {\n\t\t// Set render mode so that we can differentiate where the render request\n\t\t// is coming from. We need this because forceUpdate should never call\n\t\t// shouldComponentUpdate\n\t\tthis._force = true;\n\t\tif (callback) this._renderCallbacks.push(callback);\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Accepts `props` and `state`, and returns a new Virtual DOM tree to build.\n * Virtual DOM is generally constructed via [JSX](http://jasonformat.com/wtf-is-jsx).\n * @param {object} props Props (eg: JSX attributes) received from parent\n * element/component\n * @param {object} state The component's current state\n * @param {object} context Context object, as returned by the nearest\n * ancestor's `getChildContext()`\n * @returns {import('./index').ComponentChildren | void}\n */\nComponent.prototype.render = Fragment;\n\n/**\n * @param {import('./internal').VNode} vnode\n * @param {number | null} [childIndex]\n */\nexport function getDomSibling(vnode, childIndex) {\n\tif (childIndex == null) {\n\t\t// Use childIndex==null as a signal to resume the search from the vnode's sibling\n\t\treturn vnode._parent\n\t\t\t? getDomSibling(vnode._parent, vnode._parent._children.indexOf(vnode) + 1)\n\t\t\t: null;\n\t}\n\n\tlet sibling;\n\tfor (; childIndex < vnode._children.length; childIndex++) {\n\t\tsibling = vnode._children[childIndex];\n\n\t\tif (sibling != null && sibling._dom != null) {\n\t\t\t// Since updateParentDomPointers keeps _dom pointer correct,\n\t\t\t// we can rely on _dom to tell us if this subtree contains a\n\t\t\t// rendered DOM node, and what the first rendered DOM node is\n\t\t\treturn sibling._dom;\n\t\t}\n\t}\n\n\t// If we get here, we have not found a DOM node in this vnode's children.\n\t// We must resume from this vnode's sibling (in it's parent _children array)\n\t// Only climb up and search the parent if we aren't searching through a DOM\n\t// VNode (meaning we reached the DOM parent of the original vnode that began\n\t// the search)\n\treturn typeof vnode.type == 'function' ? getDomSibling(vnode) : null;\n}\n\n/**\n * Trigger in-place re-rendering of a component.\n * @param {import('./internal').Component} component The component to rerender\n */\nfunction renderComponent(component) {\n\tlet vnode = component._vnode,\n\t\toldDom = vnode._dom,\n\t\tparentDom = component._parentDom;\n\n\tif (parentDom) {\n\t\tlet commitQueue = [];\n\t\tconst oldVNode = assign({}, vnode);\n\t\toldVNode._original = vnode._original + 1;\n\n\t\tdiff(\n\t\t\tparentDom,\n\t\t\tvnode,\n\t\t\toldVNode,\n\t\t\tcomponent._globalContext,\n\t\t\tparentDom.ownerSVGElement !== undefined,\n\t\t\tvnode._hydrating != null ? [oldDom] : null,\n\t\t\tcommitQueue,\n\t\t\toldDom == null ? getDomSibling(vnode) : oldDom,\n\t\t\tvnode._hydrating\n\t\t);\n\t\tcommitRoot(commitQueue, vnode);\n\n\t\tif (vnode._dom != oldDom) {\n\t\t\tupdateParentDomPointers(vnode);\n\t\t}\n\t}\n}\n\n/**\n * @param {import('./internal').VNode} vnode\n */\nfunction updateParentDomPointers(vnode) {\n\tif ((vnode = vnode._parent) != null && vnode._component != null) {\n\t\tvnode._dom = vnode._component.base = null;\n\t\tfor (let i = 0; i < vnode._children.length; i++) {\n\t\t\tlet child = vnode._children[i];\n\t\t\tif (child != null && child._dom != null) {\n\t\t\t\tvnode._dom = vnode._component.base = child._dom;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn updateParentDomPointers(vnode);\n\t}\n}\n\n/**\n * The render queue\n * @type {Array<import('./internal').Component>}\n */\nlet rerenderQueue = [];\n\n/**\n * Asynchronously schedule a callback\n * @type {(cb: () => void) => void}\n */\n/* istanbul ignore next */\n// Note the following line isn't tree-shaken by rollup cuz of rollup/rollup#2566\nconst defer =\n\ttypeof Promise == 'function'\n\t\t? Promise.prototype.then.bind(Promise.resolve())\n\t\t: setTimeout;\n\n/*\n * The value of `Component.debounce` must asynchronously invoke the passed in callback. It is\n * important that contributors to Preact can consistently reason about what calls to `setState`, etc.\n * do, and when their effects will be applied. See the links below for some further reading on designing\n * asynchronous APIs.\n * * [Designing APIs for Asynchrony](https://blog.izs.me/2013/08/designing-apis-for-asynchrony)\n * * [Callbacks synchronous and asynchronous](https://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/)\n */\n\nlet prevDebounce;\n\n/**\n * Enqueue a rerender of a component\n * @param {import('./internal').Component} c The component to rerender\n */\nexport function enqueueRender(c) {\n\tif (\n\t\t(!c._dirty &&\n\t\t\t(c._dirty = true) &&\n\t\t\trerenderQueue.push(c) &&\n\t\t\t!process._rerenderCount++) ||\n\t\tprevDebounce !== options.debounceRendering\n\t) {\n\t\tprevDebounce = options.debounceRendering;\n\t\t(prevDebounce || defer)(process);\n\t}\n}\n\n/** Flush the render queue by rerendering all queued components */\nfunction process() {\n\tlet queue;\n\twhile ((process._rerenderCount = rerenderQueue.length)) {\n\t\tqueue = rerenderQueue.sort((a, b) => a._vnode._depth - b._vnode._depth);\n\t\trerenderQueue = [];\n\t\t// Don't update `renderCount` yet. Keep its value non-zero to prevent unnecessary\n\t\t// process() calls from getting scheduled while `queue` is still being consumed.\n\t\tqueue.some(c => {\n\t\t\tif (c._dirty) renderComponent(c);\n\t\t});\n\t}\n}\nprocess._rerenderCount = 0;\n", "import { enqueueRender } from './component';\n\nexport let i = 0;\n\nexport function createContext(defaultValue, contextId) {\n\tcontextId = '__cC' + i++;\n\n\tconst context = {\n\t\t_id: contextId,\n\t\t_defaultValue: defaultValue,\n\t\t/** @type {import('./internal').FunctionComponent} */\n\t\tConsumer(props, contextValue) {\n\t\t\t// return props.children(\n\t\t\t// \tcontext[contextId] ? context[contextId].props.value : defaultValue\n\t\t\t// );\n\t\t\treturn props.children(contextValue);\n\t\t},\n\t\t/** @type {import('./internal').FunctionComponent} */\n\t\tProvider(props) {\n\t\t\tif (!this.getChildContext) {\n\t\t\t\tlet subs = [];\n\t\t\t\tlet ctx = {};\n\t\t\t\tctx[contextId] = this;\n\n\t\t\t\tthis.getChildContext = () => ctx;\n\n\t\t\t\tthis.shouldComponentUpdate = function(_props) {\n\t\t\t\t\tif (this.props.value !== _props.value) {\n\t\t\t\t\t\t// I think the forced value propagation here was only needed when `options.debounceRendering` was being bypassed:\n\t\t\t\t\t\t// https://github.com/preactjs/preact/commit/4d339fb803bea09e9f198abf38ca1bf8ea4b7771#diff-54682ce380935a717e41b8bfc54737f6R358\n\t\t\t\t\t\t// In those cases though, even with the value corrected, we're double-rendering all nodes.\n\t\t\t\t\t\t// It might be better to just tell folks not to use force-sync mode.\n\t\t\t\t\t\t// Currently, using `useContext()` in a class component will overwrite its `this.context` value.\n\t\t\t\t\t\t// subs.some(c => {\n\t\t\t\t\t\t// \tc.context = _props.value;\n\t\t\t\t\t\t// \tenqueueRender(c);\n\t\t\t\t\t\t// });\n\n\t\t\t\t\t\t// subs.some(c => {\n\t\t\t\t\t\t// \tc.context[contextId] = _props.value;\n\t\t\t\t\t\t// \tenqueueRender(c);\n\t\t\t\t\t\t// });\n\t\t\t\t\t\tsubs.some(enqueueRender);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tthis.sub = c => {\n\t\t\t\t\tsubs.push(c);\n\t\t\t\t\tlet old = c.componentWillUnmount;\n\t\t\t\t\tc.componentWillUnmount = () => {\n\t\t\t\t\t\tsubs.splice(subs.indexOf(c), 1);\n\t\t\t\t\t\tif (old) old.call(c);\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn props.children;\n\t\t}\n\t};\n\n\t// Devtools needs access to the context object when it\n\t// encounters a Provider. This is necessary to support\n\t// setting `displayName` on the context object instead\n\t// of on the component itself. See:\n\t// https://reactjs.org/docs/context.html#contextdisplayname\n\n\treturn (context.Provider._contextRef = context.Consumer.contextType = context);\n}\n", "import { diff, unmount, applyRef } from './index';\nimport { createVNode, Fragment } from '../create-element';\nimport { EMPTY_OBJ, EMPTY_ARR } from '../constants';\nimport { getDomSibling } from '../component';\n\n/**\n * Diff the children of a virtual node\n * @param {import('../internal').PreactElement} parentDom The DOM element whose\n * children are being diffed\n * @param {import('../internal').ComponentChildren[]} renderResult\n * @param {import('../internal').VNode} newParentVNode The new virtual\n * node whose children should be diff'ed against oldParentVNode\n * @param {import('../internal').VNode} oldParentVNode The old virtual\n * node whose children should be diff'ed against newParentVNode\n * @param {object} globalContext The current context object - modified by getChildContext\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node\n * @param {Array<import('../internal').PreactElement>} excessDomChildren\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {import('../internal').PreactElement} oldDom The current attached DOM\n * element any new dom elements should be placed around. Likely `null` on first\n * render (except when hydrating). Can be a sibling DOM element when diffing\n * Fragments that have siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} isHydrating Whether or not we are in hydration\n */\nexport function diffChildren(\n\tparentDom,\n\trenderResult,\n\tnewParentVNode,\n\toldParentVNode,\n\tglobalContext,\n\tisSvg,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating\n) {\n\tlet i, j, oldVNode, childVNode, newDom, firstChildDom, refs;\n\n\t// This is a compression of oldParentVNode!=null && oldParentVNode != EMPTY_OBJ && oldParentVNode._children || EMPTY_ARR\n\t// as EMPTY_OBJ._children should be `undefined`.\n\tlet oldChildren = (oldParentVNode && oldParentVNode._children) || EMPTY_ARR;\n\n\tlet oldChildrenLength = oldChildren.length;\n\n\tnewParentVNode._children = [];\n\tfor (i = 0; i < renderResult.length; i++) {\n\t\tchildVNode = renderResult[i];\n\n\t\tif (childVNode == null || typeof childVNode == 'boolean') {\n\t\t\tchildVNode = newParentVNode._children[i] = null;\n\t\t}\n\t\t// If this newVNode is being reused (e.g. <div>{reuse}{reuse}</div>) in the same diff,\n\t\t// or we are rendering a component (e.g. setState) copy the oldVNodes so it can have\n\t\t// it's own DOM & etc. pointers\n\t\telse if (\n\t\t\ttypeof childVNode == 'string' ||\n\t\t\ttypeof childVNode == 'number' ||\n\t\t\t// eslint-disable-next-line valid-typeof\n\t\t\ttypeof childVNode == 'bigint'\n\t\t) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tnull,\n\t\t\t\tchildVNode,\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\tchildVNode\n\t\t\t);\n\t\t} else if (Array.isArray(childVNode)) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tFragment,\n\t\t\t\t{ children: childVNode },\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\tnull\n\t\t\t);\n\t\t} else if (childVNode._depth > 0) {\n\t\t\t// VNode is already in use, clone it. This can happen in the following\n\t\t\t// scenario:\n\t\t\t//   const reuse = <div />\n\t\t\t//   <div>{reuse}<span />{reuse}</div>\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tchildVNode.type,\n\t\t\t\tchildVNode.props,\n\t\t\t\tchildVNode.key,\n\t\t\t\tnull,\n\t\t\t\tchildVNode._original\n\t\t\t);\n\t\t} else {\n\t\t\tchildVNode = newParentVNode._children[i] = childVNode;\n\t\t}\n\n\t\t// Terser removes the `continue` here and wraps the loop body\n\t\t// in a `if (childVNode) { ... } condition\n\t\tif (childVNode == null) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tchildVNode._parent = newParentVNode;\n\t\tchildVNode._depth = newParentVNode._depth + 1;\n\n\t\t// Check if we find a corresponding element in oldChildren.\n\t\t// If found, delete the array item by setting to `undefined`.\n\t\t// We use `undefined`, as `null` is reserved for empty placeholders\n\t\t// (holes).\n\t\toldVNode = oldChildren[i];\n\n\t\tif (\n\t\t\toldVNode === null ||\n\t\t\t(oldVNode &&\n\t\t\t\tchildVNode.key == oldVNode.key &&\n\t\t\t\tchildVNode.type === oldVNode.type)\n\t\t) {\n\t\t\toldChildren[i] = undefined;\n\t\t} else {\n\t\t\t// Either oldVNode === undefined or oldChildrenLength > 0,\n\t\t\t// so after this loop oldVNode == null or oldVNode is a valid value.\n\t\t\tfor (j = 0; j < oldChildrenLength; j++) {\n\t\t\t\toldVNode = oldChildren[j];\n\t\t\t\t// If childVNode is unkeyed, we only match similarly unkeyed nodes, otherwise we match by key.\n\t\t\t\t// We always match by type (in either case).\n\t\t\t\tif (\n\t\t\t\t\toldVNode &&\n\t\t\t\t\tchildVNode.key == oldVNode.key &&\n\t\t\t\t\tchildVNode.type === oldVNode.type\n\t\t\t\t) {\n\t\t\t\t\toldChildren[j] = undefined;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\toldVNode = null;\n\t\t\t}\n\t\t}\n\n\t\toldVNode = oldVNode || EMPTY_OBJ;\n\n\t\t// Morph the old element into the new one, but don't append it to the dom yet\n\t\tdiff(\n\t\t\tparentDom,\n\t\t\tchildVNode,\n\t\t\toldVNode,\n\t\t\tglobalContext,\n\t\t\tisSvg,\n\t\t\texcessDomChildren,\n\t\t\tcommitQueue,\n\t\t\toldDom,\n\t\t\tisHydrating\n\t\t);\n\n\t\tnewDom = childVNode._dom;\n\n\t\tif ((j = childVNode.ref) && oldVNode.ref != j) {\n\t\t\tif (!refs) refs = [];\n\t\t\tif (oldVNode.ref) refs.push(oldVNode.ref, null, childVNode);\n\t\t\trefs.push(j, childVNode._component || newDom, childVNode);\n\t\t}\n\n\t\tif (newDom != null) {\n\t\t\tif (firstChildDom == null) {\n\t\t\t\tfirstChildDom = newDom;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\ttypeof childVNode.type == 'function' &&\n\t\t\t\tchildVNode._children != null && // Can be null if childVNode suspended\n\t\t\t\tchildVNode._children === oldVNode._children\n\t\t\t) {\n\t\t\t\tchildVNode._nextDom = oldDom = reorderChildren(\n\t\t\t\t\tchildVNode,\n\t\t\t\t\toldDom,\n\t\t\t\t\tparentDom\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\toldDom = placeChild(\n\t\t\t\t\tparentDom,\n\t\t\t\t\tchildVNode,\n\t\t\t\t\toldVNode,\n\t\t\t\t\toldChildren,\n\t\t\t\t\tnewDom,\n\t\t\t\t\toldDom\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Browsers will infer an option's `value` from `textContent` when\n\t\t\t// no value is present. This essentially bypasses our code to set it\n\t\t\t// later in `diff()`. It works fine in all browsers except for IE11\n\t\t\t// where it breaks setting `select.value`. There it will be always set\n\t\t\t// to an empty string. Re-applying an options value will fix that, so\n\t\t\t// there are probably some internal data structures that aren't\n\t\t\t// updated properly.\n\t\t\t//\n\t\t\t// To fix it we make sure to reset the inferred value, so that our own\n\t\t\t// value check in `diff()` won't be skipped.\n\t\t\tif (!isHydrating && newParentVNode.type === 'option') {\n\t\t\t\t// @ts-ignore We have validated that the type of parentDOM is 'option'\n\t\t\t\t// in the above check\n\t\t\t\tparentDom.value = '';\n\t\t\t} else if (typeof newParentVNode.type == 'function') {\n\t\t\t\t// Because the newParentVNode is Fragment-like, we need to set it's\n\t\t\t\t// _nextDom property to the nextSibling of its last child DOM node.\n\t\t\t\t//\n\t\t\t\t// `oldDom` contains the correct value here because if the last child\n\t\t\t\t// is a Fragment-like, then oldDom has already been set to that child's _nextDom.\n\t\t\t\t// If the last child is a DOM VNode, then oldDom will be set to that DOM\n\t\t\t\t// node's nextSibling.\n\t\t\t\tnewParentVNode._nextDom = oldDom;\n\t\t\t}\n\t\t} else if (\n\t\t\toldDom &&\n\t\t\toldVNode._dom == oldDom &&\n\t\t\toldDom.parentNode != parentDom\n\t\t) {\n\t\t\t// The above condition is to handle null placeholders. See test in placeholder.test.js:\n\t\t\t// `efficiently replace null placeholders in parent rerenders`\n\t\t\toldDom = getDomSibling(oldVNode);\n\t\t}\n\t}\n\n\tnewParentVNode._dom = firstChildDom;\n\n\t// Remove remaining oldChildren if there are any.\n\tfor (i = oldChildrenLength; i--; ) {\n\t\tif (oldChildren[i] != null) {\n\t\t\tif (\n\t\t\t\ttypeof newParentVNode.type == 'function' &&\n\t\t\t\toldChildren[i]._dom != null &&\n\t\t\t\toldChildren[i]._dom == newParentVNode._nextDom\n\t\t\t) {\n\t\t\t\t// If the newParentVNode.__nextDom points to a dom node that is about to\n\t\t\t\t// be unmounted, then get the next sibling of that vnode and set\n\t\t\t\t// _nextDom to it\n\t\t\t\tnewParentVNode._nextDom = getDomSibling(oldParentVNode, i + 1);\n\t\t\t}\n\n\t\t\tunmount(oldChildren[i], oldChildren[i]);\n\t\t}\n\t}\n\n\t// Set refs only after unmount\n\tif (refs) {\n\t\tfor (i = 0; i < refs.length; i++) {\n\t\t\tapplyRef(refs[i], refs[++i], refs[++i]);\n\t\t}\n\t}\n}\n\nfunction reorderChildren(childVNode, oldDom, parentDom) {\n\tfor (let tmp = 0; tmp < childVNode._children.length; tmp++) {\n\t\tlet vnode = childVNode._children[tmp];\n\t\tif (vnode) {\n\t\t\t// We typically enter this code path on sCU bailout, where we copy\n\t\t\t// oldVNode._children to newVNode._children. If that is the case, we need\n\t\t\t// to update the old children's _parent pointer to point to the newVNode\n\t\t\t// (childVNode here).\n\t\t\tvnode._parent = childVNode;\n\n\t\t\tif (typeof vnode.type == 'function') {\n\t\t\t\toldDom = reorderChildren(vnode, oldDom, parentDom);\n\t\t\t} else {\n\t\t\t\toldDom = placeChild(\n\t\t\t\t\tparentDom,\n\t\t\t\t\tvnode,\n\t\t\t\t\tvnode,\n\t\t\t\t\tchildVNode._children,\n\t\t\t\t\tvnode._dom,\n\t\t\t\t\toldDom\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn oldDom;\n}\n\n/**\n * Flatten and loop through the children of a virtual node\n * @param {import('../index').ComponentChildren} children The unflattened\n * children of a virtual node\n * @returns {import('../internal').VNode[]}\n */\nexport function toChildArray(children, out) {\n\tout = out || [];\n\tif (children == null || typeof children == 'boolean') {\n\t} else if (Array.isArray(children)) {\n\t\tchildren.some(child => {\n\t\t\ttoChildArray(child, out);\n\t\t});\n\t} else {\n\t\tout.push(children);\n\t}\n\treturn out;\n}\n\nfunction placeChild(\n\tparentDom,\n\tchildVNode,\n\toldVNode,\n\toldChildren,\n\tnewDom,\n\toldDom\n) {\n\tlet nextDom;\n\tif (childVNode._nextDom !== undefined) {\n\t\t// Only Fragments or components that return Fragment like VNodes will\n\t\t// have a non-undefined _nextDom. Continue the diff from the sibling\n\t\t// of last DOM child of this child VNode\n\t\tnextDom = childVNode._nextDom;\n\n\t\t// Eagerly cleanup _nextDom. We don't need to persist the value because\n\t\t// it is only used by `diffChildren` to determine where to resume the diff after\n\t\t// diffing Components and Fragments. Once we store it the nextDOM local var, we\n\t\t// can clean up the property\n\t\tchildVNode._nextDom = undefined;\n\t} else if (\n\t\toldVNode == null ||\n\t\tnewDom != oldDom ||\n\t\tnewDom.parentNode == null\n\t) {\n\t\touter: if (oldDom == null || oldDom.parentNode !== parentDom) {\n\t\t\tparentDom.appendChild(newDom);\n\t\t\tnextDom = null;\n\t\t} else {\n\t\t\t// `j<oldChildrenLength; j+=2` is an alternative to `j++<oldChildrenLength/2`\n\t\t\tfor (\n\t\t\t\tlet sibDom = oldDom, j = 0;\n\t\t\t\t(sibDom = sibDom.nextSibling) && j < oldChildren.length;\n\t\t\t\tj += 2\n\t\t\t) {\n\t\t\t\tif (sibDom == newDom) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t}\n\t\t\tparentDom.insertBefore(newDom, oldDom);\n\t\t\tnextDom = oldDom;\n\t\t}\n\t}\n\n\t// If we have pre-calculated the nextDOM node, use it. Else calculate it now\n\t// Strictly check for `undefined` here cuz `null` is a valid value of `nextDom`.\n\t// See more detail in create-element.js:createVNode\n\tif (nextDom !== undefined) {\n\t\toldDom = nextDom;\n\t} else {\n\t\toldDom = newDom.nextSibling;\n\t}\n\n\treturn oldDom;\n}\n", "import { IS_NON_DIMENSIONAL } from '../constants';\nimport options from '../options';\n\n/**\n * Diff the old and new properties of a VNode and apply changes to the DOM node\n * @param {import('../internal').PreactElement} dom The DOM node to apply\n * changes to\n * @param {object} newProps The new props\n * @param {object} oldProps The old props\n * @param {boolean} isSvg Whether or not this node is an SVG node\n * @param {boolean} hydrate Whether or not we are in hydration mode\n */\nexport function diffProps(dom, newProps, oldProps, isSvg, hydrate) {\n\tlet i;\n\n\tfor (i in oldProps) {\n\t\tif (i !== 'children' && i !== 'key' && !(i in newProps)) {\n\t\t\tsetProperty(dom, i, null, oldProps[i], isSvg);\n\t\t}\n\t}\n\n\tfor (i in newProps) {\n\t\tif (\n\t\t\t(!hydrate || typeof newProps[i] == 'function') &&\n\t\t\ti !== 'children' &&\n\t\t\ti !== 'key' &&\n\t\t\ti !== 'value' &&\n\t\t\ti !== 'checked' &&\n\t\t\toldProps[i] !== newProps[i]\n\t\t) {\n\t\t\tsetProperty(dom, i, newProps[i], oldProps[i], isSvg);\n\t\t}\n\t}\n}\n\nfunction setStyle(style, key, value) {\n\tif (key[0] === '-') {\n\t\tstyle.setProperty(key, value);\n\t} else if (value == null) {\n\t\tstyle[key] = '';\n\t} else if (typeof value != 'number' || IS_NON_DIMENSIONAL.test(key)) {\n\t\tstyle[key] = value;\n\t} else {\n\t\tstyle[key] = value + 'px';\n\t}\n}\n\n/**\n * Set a property value on a DOM node\n * @param {import('../internal').PreactElement} dom The DOM node to modify\n * @param {string} name The name of the property to set\n * @param {*} value The value to set the property to\n * @param {*} oldValue The old value the property had\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node or not\n */\nexport function setProperty(dom, name, value, oldValue, isSvg) {\n\tlet useCapture;\n\n\to: if (name === 'style') {\n\t\tif (typeof value == 'string') {\n\t\t\tdom.style.cssText = value;\n\t\t} else {\n\t\t\tif (typeof oldValue == 'string') {\n\t\t\t\tdom.style.cssText = oldValue = '';\n\t\t\t}\n\n\t\t\tif (oldValue) {\n\t\t\t\tfor (name in oldValue) {\n\t\t\t\t\tif (!(value && name in value)) {\n\t\t\t\t\t\tsetStyle(dom.style, name, '');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (value) {\n\t\t\t\tfor (name in value) {\n\t\t\t\t\tif (!oldValue || value[name] !== oldValue[name]) {\n\t\t\t\t\t\tsetStyle(dom.style, name, value[name]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// Benchmark for comparison: https://esbench.com/bench/574c954bdb965b9a00965ac6\n\telse if (name[0] === 'o' && name[1] === 'n') {\n\t\tuseCapture = name !== (name = name.replace(/Capture$/, ''));\n\n\t\t// Infer correct casing for DOM built-in events:\n\t\tif (name.toLowerCase() in dom) name = name.toLowerCase().slice(2);\n\t\telse name = name.slice(2);\n\n\t\tif (!dom._listeners) dom._listeners = {};\n\t\tdom._listeners[name + useCapture] = value;\n\n\t\tif (value) {\n\t\t\tif (!oldValue) {\n\t\t\t\tconst handler = useCapture ? eventProxyCapture : eventProxy;\n\t\t\t\tdom.addEventListener(name, handler, useCapture);\n\t\t\t}\n\t\t} else {\n\t\t\tconst handler = useCapture ? eventProxyCapture : eventProxy;\n\t\t\tdom.removeEventListener(name, handler, useCapture);\n\t\t}\n\t} else if (name !== 'dangerouslySetInnerHTML') {\n\t\tif (isSvg) {\n\t\t\t// Normalize incorrect prop usage for SVG:\n\t\t\t// - xlink:href / xlinkHref --> href (xlink:href was removed from SVG and isn't needed)\n\t\t\t// - className --> class\n\t\t\tname = name.replace(/xlink[H:h]/, 'h').replace(/sName$/, 's');\n\t\t} else if (\n\t\t\tname !== 'href' &&\n\t\t\tname !== 'list' &&\n\t\t\tname !== 'form' &&\n\t\t\t// Default value in browsers is `-1` and an empty string is\n\t\t\t// cast to `0` instead\n\t\t\tname !== 'tabIndex' &&\n\t\t\tname !== 'download' &&\n\t\t\tname in dom\n\t\t) {\n\t\t\ttry {\n\t\t\t\tdom[name] = value == null ? '' : value;\n\t\t\t\t// labelled break is 1b smaller here than a return statement (sorry)\n\t\t\t\tbreak o;\n\t\t\t} catch (e) {}\n\t\t}\n\n\t\t// ARIA-attributes have a different notion of boolean values.\n\t\t// The value `false` is different from the attribute not\n\t\t// existing on the DOM, so we can't remove it. For non-boolean\n\t\t// ARIA-attributes we could treat false as a removal, but the\n\t\t// amount of exceptions would cost us too many bytes. On top of\n\t\t// that other VDOM frameworks also always stringify `false`.\n\n\t\tif (typeof value === 'function') {\n\t\t\t// never serialize functions as attribute values\n\t\t} else if (\n\t\t\tvalue != null &&\n\t\t\t(value !== false || (name[0] === 'a' && name[1] === 'r'))\n\t\t) {\n\t\t\tdom.setAttribute(name, value);\n\t\t} else {\n\t\t\tdom.removeAttribute(name);\n\t\t}\n\t}\n}\n\n/**\n * Proxy an event to hooked event handlers\n * @param {Event} e The event object from the browser\n * @private\n */\nfunction eventProxy(e) {\n\tthis._listeners[e.type + false](options.event ? options.event(e) : e);\n}\n\nfunction eventProxyCapture(e) {\n\tthis._listeners[e.type + true](options.event ? options.event(e) : e);\n}\n", "import { EMPTY_OBJ } from '../constants';\nimport { Component, getDomSibling } from '../component';\nimport { Fragment } from '../create-element';\nimport { diffChildren } from './children';\nimport { diffProps, setProperty } from './props';\nimport { assign, removeNode, slice } from '../util';\nimport options from '../options';\n\n/**\n * Diff two virtual nodes and apply proper changes to the DOM\n * @param {import('../internal').PreactElement} parentDom The parent of the DOM element\n * @param {import('../internal').VNode} newVNode The new virtual node\n * @param {import('../internal').VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object. Modified by getChildContext\n * @param {boolean} isSvg Whether or not this element is an SVG node\n * @param {Array<import('../internal').PreactElement>} excessDomChildren\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {import('../internal').PreactElement} oldDom The current attached DOM\n * element any new dom elements should be placed around. Likely `null` on first\n * render (except when hydrating). Can be a sibling DOM element when diffing\n * Fragments that have siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} [isHydrating] Whether or not we are in hydration\n */\nexport function diff(\n\tparentDom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tisSvg,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating\n) {\n\tlet tmp,\n\t\tnewType = newVNode.type;\n\n\t// When passing through createElement it assigns the object\n\t// constructor as undefined. This to prevent JSON-injection.\n\tif (newVNode.constructor !== undefined) return null;\n\n\t// If the previous diff bailed out, resume creating/hydrating.\n\tif (oldVNode._hydrating != null) {\n\t\tisHydrating = oldVNode._hydrating;\n\t\toldDom = newVNode._dom = oldVNode._dom;\n\t\t// if we resume, we want the tree to be \"unlocked\"\n\t\tnewVNode._hydrating = null;\n\t\texcessDomChildren = [oldDom];\n\t}\n\n\tif ((tmp = options._diff)) tmp(newVNode);\n\n\ttry {\n\t\touter: if (typeof newType == 'function') {\n\t\t\tlet c, isNew, oldProps, oldState, snapshot, clearProcessingException;\n\t\t\tlet newProps = newVNode.props;\n\n\t\t\t// Necessary for createContext api. Setting this property will pass\n\t\t\t// the context value as `this.context` just for this component.\n\t\t\ttmp = newType.contextType;\n\t\t\tlet provider = tmp && globalContext[tmp._id];\n\t\t\tlet componentContext = tmp\n\t\t\t\t? provider\n\t\t\t\t\t? provider.props.value\n\t\t\t\t\t: tmp._defaultValue\n\t\t\t\t: globalContext;\n\n\t\t\t// Get component and set it to `c`\n\t\t\tif (oldVNode._component) {\n\t\t\t\tc = newVNode._component = oldVNode._component;\n\t\t\t\tclearProcessingException = c._processingException = c._pendingError;\n\t\t\t} else {\n\t\t\t\t// Instantiate the new component\n\t\t\t\tif ('prototype' in newType && newType.prototype.render) {\n\t\t\t\t\t// @ts-ignore The check above verifies that newType is suppose to be constructed\n\t\t\t\t\tnewVNode._component = c = new newType(newProps, componentContext); // eslint-disable-line new-cap\n\t\t\t\t} else {\n\t\t\t\t\t// @ts-ignore Trust me, Component implements the interface we want\n\t\t\t\t\tnewVNode._component = c = new Component(newProps, componentContext);\n\t\t\t\t\tc.constructor = newType;\n\t\t\t\t\tc.render = doRender;\n\t\t\t\t}\n\t\t\t\tif (provider) provider.sub(c);\n\n\t\t\t\tc.props = newProps;\n\t\t\t\tif (!c.state) c.state = {};\n\t\t\t\tc.context = componentContext;\n\t\t\t\tc._globalContext = globalContext;\n\t\t\t\tisNew = c._dirty = true;\n\t\t\t\tc._renderCallbacks = [];\n\t\t\t}\n\n\t\t\t// Invoke getDerivedStateFromProps\n\t\t\tif (c._nextState == null) {\n\t\t\t\tc._nextState = c.state;\n\t\t\t}\n\t\t\tif (newType.getDerivedStateFromProps != null) {\n\t\t\t\tif (c._nextState == c.state) {\n\t\t\t\t\tc._nextState = assign({}, c._nextState);\n\t\t\t\t}\n\n\t\t\t\tassign(\n\t\t\t\t\tc._nextState,\n\t\t\t\t\tnewType.getDerivedStateFromProps(newProps, c._nextState)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\toldProps = c.props;\n\t\t\toldState = c.state;\n\n\t\t\t// Invoke pre-render lifecycle methods\n\t\t\tif (isNew) {\n\t\t\t\tif (\n\t\t\t\t\tnewType.getDerivedStateFromProps == null &&\n\t\t\t\t\tc.componentWillMount != null\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillMount();\n\t\t\t\t}\n\n\t\t\t\tif (c.componentDidMount != null) {\n\t\t\t\t\tc._renderCallbacks.push(c.componentDidMount);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (\n\t\t\t\t\tnewType.getDerivedStateFromProps == null &&\n\t\t\t\t\tnewProps !== oldProps &&\n\t\t\t\t\tc.componentWillReceiveProps != null\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillReceiveProps(newProps, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\t(!c._force &&\n\t\t\t\t\t\tc.shouldComponentUpdate != null &&\n\t\t\t\t\t\tc.shouldComponentUpdate(\n\t\t\t\t\t\t\tnewProps,\n\t\t\t\t\t\t\tc._nextState,\n\t\t\t\t\t\t\tcomponentContext\n\t\t\t\t\t\t) === false) ||\n\t\t\t\t\tnewVNode._original === oldVNode._original\n\t\t\t\t) {\n\t\t\t\t\tc.props = newProps;\n\t\t\t\t\tc.state = c._nextState;\n\t\t\t\t\t// More info about this here: https://gist.github.com/JoviDeCroock/bec5f2ce93544d2e6070ef8e0036e4e8\n\t\t\t\t\tif (newVNode._original !== oldVNode._original) c._dirty = false;\n\t\t\t\t\tc._vnode = newVNode;\n\t\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t\t\tnewVNode._children.forEach(vnode => {\n\t\t\t\t\t\tif (vnode) vnode._parent = newVNode;\n\t\t\t\t\t});\n\t\t\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\t\t\tcommitQueue.push(c);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\n\t\t\t\tif (c.componentWillUpdate != null) {\n\t\t\t\t\tc.componentWillUpdate(newProps, c._nextState, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (c.componentDidUpdate != null) {\n\t\t\t\t\tc._renderCallbacks.push(() => {\n\t\t\t\t\t\tc.componentDidUpdate(oldProps, oldState, snapshot);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tc.context = componentContext;\n\t\t\tc.props = newProps;\n\t\t\tc.state = c._nextState;\n\n\t\t\tif ((tmp = options._render)) tmp(newVNode);\n\n\t\t\tc._dirty = false;\n\t\t\tc._vnode = newVNode;\n\t\t\tc._parentDom = parentDom;\n\n\t\t\ttmp = c.render(c.props, c.state, c.context);\n\n\t\t\t// Handle setState called in render, see #2553\n\t\t\tc.state = c._nextState;\n\n\t\t\tif (c.getChildContext != null) {\n\t\t\t\tglobalContext = assign(assign({}, globalContext), c.getChildContext());\n\t\t\t}\n\n\t\t\tif (!isNew && c.getSnapshotBeforeUpdate != null) {\n\t\t\t\tsnapshot = c.getSnapshotBeforeUpdate(oldProps, oldState);\n\t\t\t}\n\n\t\t\tlet isTopLevelFragment =\n\t\t\t\ttmp != null && tmp.type === Fragment && tmp.key == null;\n\t\t\tlet renderResult = isTopLevelFragment ? tmp.props.children : tmp;\n\n\t\t\tdiffChildren(\n\t\t\t\tparentDom,\n\t\t\t\tArray.isArray(renderResult) ? renderResult : [renderResult],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tisSvg,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\toldDom,\n\t\t\t\tisHydrating\n\t\t\t);\n\n\t\t\tc.base = newVNode._dom;\n\n\t\t\t// We successfully rendered this VNode, unset any stored hydration/bailout state:\n\t\t\tnewVNode._hydrating = null;\n\n\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\tcommitQueue.push(c);\n\t\t\t}\n\n\t\t\tif (clearProcessingException) {\n\t\t\t\tc._pendingError = c._processingException = null;\n\t\t\t}\n\n\t\t\tc._force = false;\n\t\t} else if (\n\t\t\texcessDomChildren == null &&\n\t\t\tnewVNode._original === oldVNode._original\n\t\t) {\n\t\t\tnewVNode._children = oldVNode._children;\n\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t} else {\n\t\t\tnewVNode._dom = diffElementNodes(\n\t\t\t\toldVNode._dom,\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tisSvg,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\tisHydrating\n\t\t\t);\n\t\t}\n\n\t\tif ((tmp = options.diffed)) tmp(newVNode);\n\t} catch (e) {\n\t\tnewVNode._original = null;\n\t\t// if hydrating or creating initial tree, bailout preserves DOM:\n\t\tif (isHydrating || excessDomChildren != null) {\n\t\t\tnewVNode._dom = oldDom;\n\t\t\tnewVNode._hydrating = !!isHydrating;\n\t\t\texcessDomChildren[excessDomChildren.indexOf(oldDom)] = null;\n\t\t\t// ^ could possibly be simplified to:\n\t\t\t// excessDomChildren.length = 0;\n\t\t}\n\t\toptions._catchError(e, newVNode, oldVNode);\n\t}\n}\n\n/**\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {import('../internal').VNode} root\n */\nexport function commitRoot(commitQueue, root) {\n\tif (options._commit) options._commit(root, commitQueue);\n\n\tcommitQueue.some(c => {\n\t\ttry {\n\t\t\t// @ts-ignore Reuse the commitQueue variable here so the type changes\n\t\t\tcommitQueue = c._renderCallbacks;\n\t\t\tc._renderCallbacks = [];\n\t\t\tcommitQueue.some(cb => {\n\t\t\t\t// @ts-ignore See above ts-ignore on commitQueue\n\t\t\t\tcb.call(c);\n\t\t\t});\n\t\t} catch (e) {\n\t\t\toptions._catchError(e, c._vnode);\n\t\t}\n\t});\n}\n\n/**\n * Diff two virtual nodes representing DOM element\n * @param {import('../internal').PreactElement} dom The DOM element representing\n * the virtual nodes being diffed\n * @param {import('../internal').VNode} newVNode The new virtual node\n * @param {import('../internal').VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node\n * @param {*} excessDomChildren\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @returns {import('../internal').PreactElement}\n */\nfunction diffElementNodes(\n\tdom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tisSvg,\n\texcessDomChildren,\n\tcommitQueue,\n\tisHydrating\n) {\n\tlet oldProps = oldVNode.props;\n\tlet newProps = newVNode.props;\n\tlet nodeType = newVNode.type;\n\tlet i = 0;\n\n\t// Tracks entering and exiting SVG namespace when descending through the tree.\n\tif (nodeType === 'svg') isSvg = true;\n\n\tif (excessDomChildren != null) {\n\t\tfor (; i < excessDomChildren.length; i++) {\n\t\t\tconst child = excessDomChildren[i];\n\n\t\t\t// if newVNode matches an element in excessDomChildren or the `dom`\n\t\t\t// argument matches an element in excessDomChildren, remove it from\n\t\t\t// excessDomChildren so it isn't later removed in diffChildren\n\t\t\tif (\n\t\t\t\tchild &&\n\t\t\t\t(child === dom ||\n\t\t\t\t\t(nodeType ? child.localName == nodeType : child.nodeType == 3))\n\t\t\t) {\n\t\t\t\tdom = child;\n\t\t\t\texcessDomChildren[i] = null;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dom == null) {\n\t\tif (nodeType === null) {\n\t\t\t// @ts-ignore createTextNode returns Text, we expect PreactElement\n\t\t\treturn document.createTextNode(newProps);\n\t\t}\n\n\t\tif (isSvg) {\n\t\t\tdom = document.createElementNS(\n\t\t\t\t'http://www.w3.org/2000/svg',\n\t\t\t\t// @ts-ignore We know `newVNode.type` is a string\n\t\t\t\tnodeType\n\t\t\t);\n\t\t} else {\n\t\t\tdom = document.createElement(\n\t\t\t\t// @ts-ignore We know `newVNode.type` is a string\n\t\t\t\tnodeType,\n\t\t\t\tnewProps.is && newProps\n\t\t\t);\n\t\t}\n\n\t\t// we created a new parent, so none of the previously attached children can be reused:\n\t\texcessDomChildren = null;\n\t\t// we are creating a new node, so we can assume this is a new subtree (in case we are hydrating), this deopts the hydrate\n\t\tisHydrating = false;\n\t}\n\n\tif (nodeType === null) {\n\t\t// During hydration, we still have to split merged text from SSR'd HTML.\n\t\tif (oldProps !== newProps && (!isHydrating || dom.data !== newProps)) {\n\t\t\tdom.data = newProps;\n\t\t}\n\t} else {\n\t\t// If excessDomChildren was not null, repopulate it with the current element's children:\n\t\texcessDomChildren = excessDomChildren && slice.call(dom.childNodes);\n\n\t\toldProps = oldVNode.props || EMPTY_OBJ;\n\n\t\tlet oldHtml = oldProps.dangerouslySetInnerHTML;\n\t\tlet newHtml = newProps.dangerouslySetInnerHTML;\n\n\t\t// During hydration, props are not diffed at all (including dangerouslySetInnerHTML)\n\t\t// @TODO we should warn in debug mode when props don't match here.\n\t\tif (!isHydrating) {\n\t\t\t// But, if we are in a situation where we are using existing DOM (e.g. replaceNode)\n\t\t\t// we should read the existing DOM attributes to diff them\n\t\t\tif (excessDomChildren != null) {\n\t\t\t\toldProps = {};\n\t\t\t\tfor (i = 0; i < dom.attributes.length; i++) {\n\t\t\t\t\toldProps[dom.attributes[i].name] = dom.attributes[i].value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (newHtml || oldHtml) {\n\t\t\t\t// Avoid re-applying the same '__html' if it did not changed between re-render\n\t\t\t\tif (\n\t\t\t\t\t!newHtml ||\n\t\t\t\t\t((!oldHtml || newHtml.__html != oldHtml.__html) &&\n\t\t\t\t\t\tnewHtml.__html !== dom.innerHTML)\n\t\t\t\t) {\n\t\t\t\t\tdom.innerHTML = (newHtml && newHtml.__html) || '';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdiffProps(dom, newProps, oldProps, isSvg, isHydrating);\n\n\t\t// If the new vnode didn't have dangerouslySetInnerHTML, diff its children\n\t\tif (newHtml) {\n\t\t\tnewVNode._children = [];\n\t\t} else {\n\t\t\ti = newVNode.props.children;\n\t\t\tdiffChildren(\n\t\t\t\tdom,\n\t\t\t\tArray.isArray(i) ? i : [i],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tisSvg && nodeType !== 'foreignObject',\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\texcessDomChildren\n\t\t\t\t\t? excessDomChildren[0]\n\t\t\t\t\t: oldVNode._children && getDomSibling(oldVNode, 0),\n\t\t\t\tisHydrating\n\t\t\t);\n\n\t\t\t// Remove children that are not part of any vnode.\n\t\t\tif (excessDomChildren != null) {\n\t\t\t\tfor (i = excessDomChildren.length; i--; ) {\n\t\t\t\t\tif (excessDomChildren[i] != null) removeNode(excessDomChildren[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// (as above, don't diff props during hydration)\n\t\tif (!isHydrating) {\n\t\t\tif (\n\t\t\t\t'value' in newProps &&\n\t\t\t\t(i = newProps.value) !== undefined &&\n\t\t\t\t// #2756 For the <progress>-element the initial value is 0,\n\t\t\t\t// despite the attribute not being present. When the attribute\n\t\t\t\t// is missing the progress bar is treated as indeterminate.\n\t\t\t\t// To fix that we'll always update it when it is 0 for progress elements\n\t\t\t\t(i !== dom.value || (nodeType === 'progress' && !i))\n\t\t\t) {\n\t\t\t\tsetProperty(dom, 'value', i, oldProps.value, false);\n\t\t\t}\n\t\t\tif (\n\t\t\t\t'checked' in newProps &&\n\t\t\t\t(i = newProps.checked) !== undefined &&\n\t\t\t\ti !== dom.checked\n\t\t\t) {\n\t\t\t\tsetProperty(dom, 'checked', i, oldProps.checked, false);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dom;\n}\n\n/**\n * Invoke or update a ref, depending on whether it is a function or object ref.\n * @param {object|function} ref\n * @param {any} value\n * @param {import('../internal').VNode} vnode\n */\nexport function applyRef(ref, value, vnode) {\n\ttry {\n\t\tif (typeof ref == 'function') ref(value);\n\t\telse ref.current = value;\n\t} catch (e) {\n\t\toptions._catchError(e, vnode);\n\t}\n}\n\n/**\n * Unmount a virtual node from the tree and apply DOM changes\n * @param {import('../internal').VNode} vnode The virtual node to unmount\n * @param {import('../internal').VNode} parentVNode The parent of the VNode that\n * initiated the unmount\n * @param {boolean} [skipRemove] Flag that indicates that a parent node of the\n * current element is already detached from the DOM.\n */\nexport function unmount(vnode, parentVNode, skipRemove) {\n\tlet r;\n\tif (options.unmount) options.unmount(vnode);\n\n\tif ((r = vnode.ref)) {\n\t\tif (!r.current || r.current === vnode._dom) applyRef(r, null, parentVNode);\n\t}\n\n\tif ((r = vnode._component) != null) {\n\t\tif (r.componentWillUnmount) {\n\t\t\ttry {\n\t\t\t\tr.componentWillUnmount();\n\t\t\t} catch (e) {\n\t\t\t\toptions._catchError(e, parentVNode);\n\t\t\t}\n\t\t}\n\n\t\tr.base = r._parentDom = null;\n\t}\n\n\tif ((r = vnode._children)) {\n\t\tfor (let i = 0; i < r.length; i++) {\n\t\t\tif (r[i]) {\n\t\t\t\tunmount(r[i], parentVNode, typeof vnode.type != 'function');\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!skipRemove && vnode._dom != null) removeNode(vnode._dom);\n\n\t// Must be set to `undefined` to properly clean up `_nextDom`\n\t// for which `null` is a valid value. See comment in `create-element.js`\n\tvnode._dom = vnode._nextDom = undefined;\n}\n\n/** The `.render()` method for a PFC backing instance. */\nfunction doRender(props, state, context) {\n\treturn this.constructor(props, context);\n}\n", "import { EMPTY_OBJ } from './constants';\nimport { commitRoot, diff } from './diff/index';\nimport { createElement, Fragment } from './create-element';\nimport options from './options';\nimport { slice } from './util';\n\n/**\n * Render a Preact virtual node into a DOM element\n * @param {import('./internal').ComponentChild} vnode The virtual node to render\n * @param {import('./internal').PreactElement} parentDom The DOM element to\n * render into\n * @param {import('./internal').PreactElement | object} [replaceNode] Optional: Attempt to re-use an\n * existing DOM tree rooted at `replaceNode`\n */\nexport function render(vnode, parentDom, replaceNode) {\n\tif (options._root) options._root(vnode, parentDom);\n\n\t// We abuse the `replaceNode` parameter in `hydrate()` to signal if we are in\n\t// hydration mode or not by passing the `hydrate` function instead of a DOM\n\t// element..\n\tlet isHydrating = typeof replaceNode === 'function';\n\n\t// To be able to support calling `render()` multiple times on the same\n\t// DOM node, we need to obtain a reference to the previous tree. We do\n\t// this by assigning a new `_children` property to DOM nodes which points\n\t// to the last rendered tree. By default this property is not present, which\n\t// means that we are mounting a new tree for the first time.\n\tlet oldVNode = isHydrating\n\t\t? null\n\t\t: (replaceNode && replaceNode._children) || parentDom._children;\n\n\tvnode = (\n\t\t(!isHydrating && replaceNode) ||\n\t\tparentDom\n\t)._children = createElement(Fragment, null, [vnode]);\n\n\t// List of effects that need to be called after diffing.\n\tlet commitQueue = [];\n\tdiff(\n\t\tparentDom,\n\t\t// Determine the new vnode tree and store it on the DOM element on\n\t\t// our custom `_children` property.\n\t\tvnode,\n\t\toldVNode || EMPTY_OBJ,\n\t\tEMPTY_OBJ,\n\t\tparentDom.ownerSVGElement !== undefined,\n\t\t!isHydrating && replaceNode\n\t\t\t? [replaceNode]\n\t\t\t: oldVNode\n\t\t\t? null\n\t\t\t: parentDom.firstChild\n\t\t\t? slice.call(parentDom.childNodes)\n\t\t\t: null,\n\t\tcommitQueue,\n\t\t!isHydrating && replaceNode\n\t\t\t? replaceNode\n\t\t\t: oldVNode\n\t\t\t? oldVNode._dom\n\t\t\t: parentDom.firstChild,\n\t\tisHydrating\n\t);\n\n\t// Flush all queued effects\n\tcommitRoot(commitQueue, vnode);\n}\n\n/**\n * Update an existing DOM element with data from a Preact virtual node\n * @param {import('./internal').ComponentChild} vnode The virtual node to render\n * @param {import('./internal').PreactElement} parentDom The DOM element to\n * update\n */\nexport function hydrate(vnode, parentDom) {\n\trender(vnode, parentDom, hydrate);\n}\n", "import { assign, slice } from './util';\nimport { createVNode } from './create-element';\n\n/**\n * Clones the given VNode, optionally adding attributes/props and replacing its children.\n * @param {import('./internal').VNode} vnode The virtual DOM element to clone\n * @param {object} props Attributes/props to add when cloning\n * @param {Array<import('./internal').ComponentChildren>} rest Any additional arguments will be used as replacement children.\n * @returns {import('./internal').VNode}\n */\nexport function cloneElement(vnode, props, children) {\n\tlet normalizedProps = assign({}, vnode.props),\n\t\tkey,\n\t\tref,\n\t\ti;\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse normalizedProps[i] = props[i];\n\t}\n\n\tif (arguments.length > 2) {\n\t\tnormalizedProps.children =\n\t\t\targuments.length > 3 ? slice.call(arguments, 2) : children;\n\t}\n\n\treturn createVNode(\n\t\tvnode.type,\n\t\tnormalizedProps,\n\t\tkey || vnode.key,\n\t\tref || vnode.ref,\n\t\tnull\n\t);\n}\n", "/**\n * Find the closest error boundary to a thrown error and call it\n * @param {object} error The thrown value\n * @param {import('../internal').VNode} vnode The vnode that threw\n * the error that was caught (except for unmounting when this parameter\n * is the highest parent that was being unmounted)\n */\nexport function _catchError(error, vnode) {\n\t/** @type {import('../internal').Component} */\n\tlet component, ctor, handled;\n\n\tfor (; (vnode = vnode._parent); ) {\n\t\tif ((component = vnode._component) && !component._processingException) {\n\t\t\ttry {\n\t\t\t\tctor = component.constructor;\n\n\t\t\t\tif (ctor && ctor.getDerivedStateFromError != null) {\n\t\t\t\t\tcomponent.setState(ctor.getDerivedStateFromError(error));\n\t\t\t\t\thandled = component._dirty;\n\t\t\t\t}\n\n\t\t\t\tif (component.componentDidCatch != null) {\n\t\t\t\t\tcomponent.componentDidCatch(error);\n\t\t\t\t\thandled = component._dirty;\n\t\t\t\t}\n\n\t\t\t\t// This is an error boundary. Mark it as having bailed out, and whether it was mid-hydration.\n\t\t\t\tif (handled) {\n\t\t\t\t\treturn (component._pendingError = component);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\terror = e;\n\t\t\t}\n\t\t}\n\t}\n\n\tthrow error;\n}\n", "import { h } from \"preact\";\n\ntype SVGProps = { fillClass: string; strokeClass: string };\n\nexport function BlankFile({ strokeClass }: SVGProps) {\n  return (\n    <svg viewBox=\"0 0 512 512\" xmlns=\"http://www.w3.org/2000/svg\">\n      <path\n        d=\"M416,221.25V416a48,48,0,0,1-48,48H144a48,48,0,0,1-48-48V96a48,48,0,0,1,48-48h98.75a32,32,0,0,1,22.62,9.37L406.63,198.63A32,32,0,0,1,416,221.25Z\"\n        className={strokeClass}\n        style=\"fill:none;stroke-linejoin:round;stroke-width:32px\"\n      />\n      <path\n        d=\"M256,56V176a32,32,0,0,0,32,32H408\"\n        className={strokeClass}\n        style=\"fill:none;stroke-linecap:round;stroke-linejoin:round;stroke-width:32px\"\n      />\n    </svg>\n  );\n}\n\nexport function ClosedFolder({ fillClass }: SVGProps) {\n  return (\n    <svg\n      xmlnsXlink=\"http://www.w3.org/1999/xlink\"\n      xmlns=\"http://www.w3.org/2000/svg\"\n      viewBox=\"0 0 512 512\"\n      version=\"1.1\"\n    >\n      <defs>\n        <path d=\"M0 0L512 0L512 512L0 512L0 0Z\" id=\"path_1\" />\n        <clipPath id=\"mask_1\">\n          <use xmlnsXlink=\"http://www.w3.org/1999/xlink\" xlinkHref=\"#path_1\" />\n        </clipPath>\n      </defs>\n      <g id=\"folder-open-outline-svgrepo-com-Copy\">\n        <path\n          d=\"M0 128L0 56C0 40.536 5.46734 27.3367 16.402 16.402C27.3367 5.46734 40.536 -3.8147e-06 56 7.62939e-06L131.89 0C143.195 0.000282288 153.551 3.13628 162.956 9.408L190.795 27.9672C194.827 30.6556 199.265 31.9999 204.11 32L360 32C375.464 32 388.663 37.4674 399.598 48.402C410.533 59.3367 416 72.536 416 88L416 128C416 132.418 414.438 136.189 411.314 139.314C408.19 142.438 404.418 144 400 144C395.582 144 391.81 142.438 388.686 139.314C385.562 136.189 384 132.418 384 128L384 88C384 81.3726 381.657 75.7157 376.971 71.0294C372.284 66.3431 366.627 64 360 64L204.11 64C192.805 63.9997 182.45 60.864 173.045 54.5928L145.204 36.032C141.173 33.3441 136.735 32.0001 131.89 32L56 32C49.3726 32 43.7157 34.3431 39.0294 39.0294C34.3431 43.7157 32 49.3726 32 56L32 128C32 132.418 30.4379 136.189 27.3137 139.314C24.1895 142.438 20.4183 144 16 144C11.5817 144 7.81048 142.438 4.68629 139.314C1.56209 136.189 -3.8147e-06 132.418 0 128L0 128Z\"\n          className={fillClass}\n          transform=\"translate(48 96)\"\n          id=\"Vector\"\n          fill-rule=\"evenodd\"\n          stroke=\"none\"\n        />\n        <path\n          xmlns=\"http://www.w3.org/2000/svg\"\n          d=\"M32 2.89864e-06Q21.4764 3.04896 13.1421 11.3833Q0 24.5254 0 43.1111L0 241.371C0 253.762 4.3807 264.338 13.1421 273.099C21.9035 281.86 32.4795 286.241 44.87 286.241L371.13 286.241C383.521 286.241 394.096 281.86 402.858 273.099C411.619 264.338 416 253.762 416 241.371L416 43.1111Q416 24.5254 402.858 11.3833C397.302 5.82706 391.016 2.03264 384 4.83332e-06L384 241.371C384 244.925 382.743 247.959 380.23 250.472C377.717 252.985 374.684 254.241 371.13 254.241L44.87 254.241C41.316 254.241 38.2826 252.985 35.7695 250.472C33.2565 247.959 32 244.925 32 241.371L32 2.89864e-06Z\"\n          className={fillClass}\n          transform=\"translate(48 161.75885)\"\n          id=\"Vector-Difference\"\n          fill-rule=\"evenodd\"\n          stroke=\"none\"\n        />\n        <path\n          d=\"M0 0L512 0L512 512L0 512L0 0Z\"\n          id=\"Background\"\n          fill=\"none\"\n          fill-rule=\"evenodd\"\n          stroke=\"none\"\n        />\n      </g>\n    </svg>\n  );\n}\n\nexport function OpenedFolder({ strokeClass }: SVGProps) {\n  return (\n    <svg\n      viewBox=\"0 0 544 544\"\n      version=\"1.1\"\n      xmlnsXlink=\"http://www.w3.org/1999/xlink\"\n      xmlns=\"http://www.w3.org/2000/svg\"\n    >\n      <defs>\n        <path d=\"M0 0L512 0L512 512L0 512L0 0Z\" id=\"path_1\" />\n        <clipPath id=\"mask_1\">\n          <use xlinkHref=\"#path_1\" />\n        </clipPath>\n      </defs>\n      <g id=\"folder-open-outline-svgrepo-com\" transform=\"translate(16 16)\">\n        <path\n          d=\"M0 0L512 0L512 512L0 512L0 0Z\"\n          id=\"Background\"\n          fill=\"none\"\n          fill-rule=\"evenodd\"\n          stroke=\"none\"\n        />\n        <g clip-path=\"url(#mask_1)\">\n          <path\n            d=\"M0 112L0 40C0 17.9086 17.9086 0 40 0L115.89 0C123.788 0.000198364 131.509 2.33844 138.08 6.72L165.92 25.28C172.491 29.6616 180.212 31.9998 188.11 32L344 32C366.091 32 384 49.9086 384 72L384 112\"\n            className={strokeClass}\n            transform=\"translate(64 80)\"\n            id=\"Shape\"\n            fill=\"none\"\n            fill-rule=\"evenodd\"\n            stroke-width=\"32\"\n            stroke-linecap=\"round\"\n            stroke-linejoin=\"round\"\n          />\n          <path\n            d=\"M447.902 34.55L431.682 200C431.682 222.064 413.816 239.961 391.752 240L56.2519 240C34.1878 239.961 16.3218 222.064 16.3219 200L0.101862 34.55C-0.609785 25.648 2.43088 16.8536 8.48899 10.2922C14.5471 3.73085 23.0714 -0.000488281 32.0019 0L416.102 0C425.015 0.027359 433.513 3.77081 439.549 10.3289C445.585 16.8869 448.612 25.6653 447.902 34.55L447.902 34.55Z\"\n            className={strokeClass}\n            transform=\"translate(31.998047 192)\"\n            id=\"Shape\"\n            fill=\"none\"\n            fill-rule=\"evenodd\"\n            stroke-width=\"32\"\n            stroke-linecap=\"round\"\n            stroke-linejoin=\"round\"\n          />\n        </g>\n      </g>\n    </svg>\n  );\n}\n", "import { h } from \"preact\";\nimport { useMemo, useState } from \"preact/hooks\";\nimport { BlankFile, ClosedFolder, OpenedFolder } from \"./icons-jsx\";\nimport { getPathName } from \"../common/util/path\";\nimport {\n  FileTreeNode as Node,\n  FileTreeNodeWithChildren as NodeWithChildren,\n} from \"../common/types\";\n\nfunction FileNode(props: {\n  visible?: boolean;\n  node: Node;\n  focusedNode?: string; // path of the focused node\n  handleFocus: (path: string) => void;\n}) {\n  const name = useMemo(() => getPathName(props.node.path), [props.node.path]);\n\n  const onClick = () => props.handleFocus(props.node.path);\n\n  return <div\n    className={\"filetree-item file\" +\n      (props.focusedNode === props.node.path ? \" focused\" : \"\") +\n      (props.visible ? \"\" : \" hidden\")}\n    onClick={onClick}\n  >\n    <div className=\"filetree-item-icon\">\n      <BlankFile fillClass=\"fill\" strokeClass=\"stroke\" />\n    </div>\n    {name}\n  </div>;\n}\n\nfunction DirNode(props: {\n  visible?: boolean; // dir is only shown if state is expanded and this boolean\n  node: NodeWithChildren;\n  initExpanded?: boolean; // is the dir open at initialization?\n  focusedNode?: string; // path of the focused node\n  handleFocus: (path: string) => void;\n}) {\n  const name = useMemo(() => getPathName(props.node.path), [props.node.path]);\n\n  const [expanded, setExpanded] = useState<boolean>(\n    props.initExpanded === undefined ? false : props.initExpanded,\n  );\n\n  const onClick = expanded ? () => setExpanded(false) : () => setExpanded(true);\n\n  return <div className=\"filetree-dir\">\n    <div\n      className={\"filetree-item\" + (props.visible && expanded ? \"\" : \" hidden\")}\n      onClick={onClick}\n    >\n      <div className=\"filetree-item-icon\">\n        {expanded\n          ? <OpenedFolder fillClass=\"fill\" strokeClass=\"stroke\" />\n          : <ClosedFolder fillClass=\"fill\" strokeClass=\"stroke\" />}\n      </div>\n      {name}\n    </div>\n    <div\n      className={\"filetree-dir-children\" +\n        (props.visible && expanded ? \"\" : \" hidden\")}\n    >\n      {props.node.children.map((node) =>\n        node.children\n          ? <DirNode\n            visible={expanded}\n            key={node.path}\n            node={node as NodeWithChildren}\n            focusedNode={props.focusedNode}\n            handleFocus={props.handleFocus}\n          />\n          : <FileNode\n            visible={expanded}\n            node={node}\n            key={node.path}\n            focusedNode={props.focusedNode}\n            handleFocus={props.handleFocus}\n          />\n      )}\n    </div>\n  </div>;\n}\n\n// file tree component\n// not meant to be used with another react component\nexport default function (props: {\n  node: NodeWithChildren;\n  initFocusedNode?: string; // path of the focused node\n  handleFocus: (path: string) => void;\n}) {\n  // console.log(\"filetree component\", props);\n\n  return <div className=\"filetree-main\">\n    <DirNode\n      visible={true}\n      key={props.node.path}\n      initExpanded={true}\n      node={props.node}\n      focusedNode={props.initFocusedNode}\n      handleFocus={props.handleFocus}\n    />\n  </div>;\n}\n", "import { FileTreeNodeWithChildren, Mnote } from \"../common/types\";\nimport { Emitter } from \"../common/emitter\";\nimport { el } from \"../common/elbuilder\";\nimport { Context } from \"./types\";\nimport { FSModule } from \"./fs\";\nimport { LayoutModule } from \"./layout\";\nimport { CtxmenuModule } from \"./ctxmenu\";\nimport { LoggingModule } from \"./logging\";\n\nimport { h, render } from \"preact\";\nimport FileTree from \"../components/filetree\";\n\nexport class FiletreeModule {\n  element: HTMLElement;\n  fs: FSModule;\n  layout: LayoutModule;\n  ctxmenu: CtxmenuModule;\n  logging: LoggingModule;\n  events: Emitter<{\n    selected: (path: string) => void;\n  }> = new Emitter();\n  selectedFile?: string;\n  tree?: FileTreeNodeWithChildren;\n  app: Mnote;\n\n  constructor(app: Mnote, startFile?: string) {\n    this.app = app;\n\n    this.element = el(\"div\")\n      .class(\"filetree-container\")\n      .element;\n\n    this.fs = app.modules.fs as FSModule;\n    this.layout = app.modules.layout as LayoutModule;\n    this.ctxmenu = app.modules.ctxmenu as CtxmenuModule;\n    this.logging = app.modules.logging as LoggingModule;\n\n    const ctxmenuReducer = (ctx: Context) => {};\n\n    this.ctxmenu.addSectionReducer(ctxmenuReducer);\n\n    this.layout.mountToFiletree(this.element);\n\n    if (startFile) this.selectedFile = startFile;\n\n    this.fs.onWatchEvent(() => this.refreshTree());\n\n    this.refreshTree();\n  }\n\n  async refreshTree() {\n    const tree = await this.fs.readDir(this.app.directory); // replace with watcher?\n\n    if (tree.children) {\n      this.setFileTree(tree as FileTreeNodeWithChildren);\n    } else {\n      this.logging.err(\n        \"filetree read directory - no children, Dir:\",\n        this.app.directory,\n      );\n    }\n  }\n\n  setFileTree(tree: FileTreeNodeWithChildren) {\n    this.logging.info(\"setFileTree\", tree);\n    this.tree = tree;\n    this.updateDisplay();\n  }\n\n  setSelectedFile(path: string) {\n    this.logging.info(\"setSelectedFile\", path);\n    this.selectedFile = path;\n    this.events.emitSync(\"selected\", path);\n    this.updateDisplay();\n  }\n\n  protected updateDisplay() {\n    this.logging.info(\"filetree updateDisplay\", this.tree, this.selectedFile);\n\n    render(\n      <FileTree\n        node={this.tree as FileTreeNodeWithChildren}\n        handleFocus={(path: string) => {\n          this.logging.info(\"path focused\", path);\n          this.setSelectedFile(path);\n        }}\n        initFocusedNode={this.selectedFile}\n      />,\n      this.element,\n    );\n  }\n}\n", "import { Mnote } from \"../common/types\";\nimport { FSModule } from \"./fs\";\nimport { LoggingModule } from \"./logging\";\nimport { Settings } from \"./types\";\nimport { Emitter } from \"../common/emitter\";\n\n/** rule to check if a value is a valid settings object */\ntype ValidSettingsRule = (value: Record<string, unknown>) => boolean;\n\n// the file is only read once at initialization. as long as the\n// app is running state is kept here and persisted based on the\n// data in this module\n\nexport class SettingsModule {\n  app: Mnote;\n  fs: FSModule;\n  logging: LoggingModule;\n\n  SETTINGS_NAME = \".mnotesettings\";\n  protected settingsPath: string;\n  protected settings: Settings = this.defaultSettings();\n\n  // see the bottom of the file\n  protected settingsRules: ValidSettingsRule[] = [\n    hasValidTheme,\n  ];\n\n  events: Emitter<{\n    change: (settings: Settings) => void | Promise<void>;\n  }> = new Emitter();\n\n  constructor(app: Mnote) {\n    this.app = app;\n    this.fs = app.modules.fs as FSModule;\n    this.logging = app.modules.logging as LoggingModule;\n  }\n\n  async init() {\n    this.settingsPath = this.fs.joinPath([\n      await this.fs.getConfigDir(),\n      this.SETTINGS_NAME,\n    ]);\n\n    try {\n      const contents = await this.fs.readTextFile(this.settingsPath);\n      const maybeSettings = JSON.parse(contents);\n      if (this.isValidSettings(maybeSettings)) {\n        this.settings = maybeSettings;\n      } else {\n        throw null;\n      }\n    } catch {\n      await this.resetSettings();\n    }\n\n    return this;\n  }\n\n  /** persist to the file */\n  protected async persistSettings() {\n    this.logging.info(\n      \"Persist settings to path\",\n      this.settingsPath,\n      this.settings,\n    );\n\n    await this.fs.writeTextFile(\n      this.settingsPath,\n      JSON.stringify(this.settings),\n    );\n  }\n\n  defaultSettings(): Settings {\n    return {};\n  }\n\n  isValidSettings(value: unknown): value is Settings {\n    if (typeof value !== \"object\") return false;\n    if (value instanceof Array) return false;\n    for (const rule of this.settingsRules) {\n      if (!rule(value as Record<string, unknown>)) return false;\n    }\n    return true;\n  }\n\n  getKey<K extends keyof Settings>(key: K): Settings[K] {\n    return this.settings[key];\n  }\n\n  setKey<K extends keyof Settings>(key: K, value: Settings[K]): Promise<void> {\n    this.settings[key] = value;\n    return this.persistSettings()\n      .then(() => this.events.emit(\"change\", this.settings));\n  }\n\n  getSettings(): Settings {\n    return this.settings;\n  }\n\n  setSettings(settings: Settings): Promise<void> {\n    this.settings = settings;\n    return this.persistSettings()\n      .then(() => this.events.emit(\"change\", this.settings));\n  }\n\n  resetSettings(): Promise<void> {\n    this.settings = this.defaultSettings();\n    return this.persistSettings()\n      .then(() => this.events.emit(\"change\", this.settings));\n  }\n}\n\nconst hasValidTheme: ValidSettingsRule = (value) => {\n  return value.theme === undefined || typeof value.theme === \"string\";\n};\n", "import OpenColor from \"open-color\";\n// note: see the reference\n// https://github.com/yeun/open-color\n\nconst gray = OpenColor.gray;\n\nexport const light = {\n  \"font-main\": \"Lato\",\n  \"font-monospace\": \"Fira Mono\",\n\n  \"fg-main\": gray[9],\n  \"fg-secondary\": gray[7],\n  \"fg-dim\": gray[5],\n\n  \"bg-main\": \"#fff\",\n  \"bg-secondary\": gray[1],\n  \"bg-dim\": gray[3],\n\n  \"shadow\": \"0px 2px 5px \" + gray[3],\n  \"overlay\": gray[7] + \"32\",\n\n  \"border-main\": gray[3],\n  \"border-dim\": gray[2],\n\n  \"sidebar-bg-main\": gray[1],\n  \"sidebar-bg-hover\": gray[3],\n  \"sidebar-fg-main\": gray[9],\n  \"sidebar-fg-secondary\": gray[9],\n\n  \"btn-main-fg\": gray[9], // buttons, assuming background is bg-main\n  \"btn-main-fg-hover\": gray[9],\n  \"btn-main-bg\": gray[2],\n  \"btn-main-bg-hover\": gray[3],\n\n  \"btn-emphasis-fg\": \"#fff\",\n  \"btn-emphasis-fg-hover\": \"#fff\",\n  \"btn-emphasis-bg\": gray[6],\n  \"btn-emphasis-bg-hover\": gray[7],\n};\n\n// dark theme from my UI prototype\n\nexport const dark = {\n  \"font-main\": \"Lato\",\n  \"font-monospace\": \"Fira Mono\",\n\n  \"fg-main\": \"#B0B6BB\",\n  \"fg-secondary\": \"#767E85\",\n  \"fg-dim\": \"#656A70\",\n\n  \"bg-main\": \"#2B2D2E\",\n  \"bg-secondary\": \"#242627\",\n  \"bg-dim\": \"#5A6164\",\n\n  \"shadow\": \"0px 2px 5px \" + \"#111\",\n  \"overlay\": \"#11111132\",\n\n  \"border-main\": \"#111\",\n  \"border-dim\": \"#111\",\n\n  \"sidebar-bg-main\": \"#242627\",\n  \"sidebar-bg-hover\": \"#2B2D2E\",\n  \"sidebar-fg-main\": \"#B0B6BB\",\n  \"sidebar-fg-secondary\": \"#767E85\",\n\n  \"btn-main-fg\": \"#B0B6BB\", // buttons, assuming background is bg-main\n  \"btn-main-fg-hover\": \"#B0B6BB\",\n  \"btn-main-bg\": \"#5A6164\",\n  \"btn-main-bg-hover\": \"#656A70\",\n\n  \"btn-emphasis-fg\": \"#2B2D2E\",\n  \"btn-emphasis-fg-hover\": \"#2B2D2E\",\n  \"btn-emphasis-bg\": \"#B0B6BB\",\n  \"btn-emphasis-bg-hover\": \"#767E85\",\n};\n\n/* oc dark theme\n\nconst darkTheme = {\n  \"font-main\": \"Lato\",\n  \"font-monospace\": \"Fira Mono\",\n\n  \"fg-main\": gray[2],\n  \"fg-secondary\": gray[4],\n  \"fg-dim\": gray[5],\n\n  \"bg-main\": gray[8],\n  \"bg-secondary\": gray[9],\n  \"bg-dim\": gray[3],\n\n  \"shadow\": \"0px 2px 5px \" + \"#111\",\n  \"overlay\": \"#11111132\",\n\n  \"border-main\": gray[9],\n  \"border-dim\": gray[9],\n\n  \"sidebar-bg-main\": gray[9],\n  \"sidebar-bg-hover\": gray[7],\n  \"sidebar-fg-main\": gray[4],\n\n  \"btn-main-fg\": gray[2], // buttons, assuming background is bg-main\n  \"btn-main-fg-hover\": gray[2],\n  \"btn-main-bg\": gray[7],\n  \"btn-main-bg-hover\": gray[6],\n\n  \"btn-emphasis-fg\": gray[9],\n  \"btn-emphasis-fg-hover\": gray[9],\n  \"btn-emphasis-bg\": gray[3],\n  \"btn-emphasis-bg-hover\": gray[4],\n}; */\n", "import { Mnote } from \"../common/types\";\nimport { Emitter } from \"../common/emitter\";\nimport { SettingsModule } from \"./settings\";\nimport { dark, light } from \"../components/colors\";\n\n// colors are declared at bottom\n\n// variables are in an \"mnote\" namespace (--mnote-<key>)\nfunction setVar(key: string, value: string) {\n  document.documentElement.style.setProperty(\"--mnote-\" + key, value);\n}\n\n// themes used to be loaded from plain tables, but it doesn't\n// work nicely when new keys are added / values are adjusted\n\n// themes module, binds the registry with the rest of the app\n\nexport class ThemesModule {\n  app: Mnote;\n  settings: SettingsModule;\n  themes: Record<string, Record<string, string>> = {\n    dark,\n    light,\n  };\n\n  events: Emitter<{\n    register: (name: string) => void | Promise<void>;\n  }> = new Emitter();\n\n  constructor(app: Mnote) {\n    this.app = app;\n    this.settings = app.modules.settings as SettingsModule;\n\n    this.settings.events.on(\"change\", () => {\n      this.init();\n    });\n\n    this.events.on(\"register\", () => {\n      this.init();\n    });\n  }\n\n  // load from settings\n  async init() {\n    const settings = this.settings.getSettings();\n    if (settings.theme) {\n      this.rawSetTheme(settings.theme);\n    } else {\n      await this.setTheme(\"light\");\n    }\n  }\n\n  protected rawSetTheme(theme: string) {\n    const colors = this.themes[theme];\n    for (const k in colors) {\n      setVar(k, colors[k]);\n    }\n  }\n\n  /** set the theme and persist */\n  async setTheme(theme: string) {\n    if (!this.hasTheme(theme)) theme = \"light\";\n    await this.settings.setKey(\"theme\", theme);\n    this.rawSetTheme(theme);\n  }\n\n  registerTheme(name: string, colors: Record<string, string>) {\n    this.themes[name] = colors;\n    this.events.emit(\"register\", name);\n    return this;\n  }\n\n  hasTheme(name: string) {\n    return this.themes[name] !== undefined;\n  }\n}\n", "import Mousetrap from \"mousetrap\";\nimport { Mnote } from \"../common/types\";\n\nexport class InputModule {\n  constructor(_: Mnote) {}\n\n  registerShortcut(\n    combinations: string[],\n    callback: (e: KeyboardEvent) => void | Promise<void>,\n  ) {\n    console.log(\"input: bind combinations\", combinations);\n    Mousetrap.bind(combinations, callback);\n  }\n}\n", "import { Mnote } from \"../common/types\";\nimport { EditorsModule } from \"../modules/editors\";\nimport {\n  DocInfo,\n  EditorContext,\n  EditorProvider,\n  Extension,\n} from \"../modules/types\";\nimport { Editor } from \"../modules/types\";\nimport { el } from \"../common/elbuilder\";\nimport { FSModule } from \"../modules/fs\";\n\n// an editor extension contains:\n// - the editor\n// - the provider\n// - the extension itself\n\nclass PlaintextEditor implements Editor {\n  app: Mnote;\n  element: HTMLElement;\n  textarea: HTMLTextAreaElement;\n  container?: HTMLElement;\n  fs: FSModule;\n\n  contents: string = \"\";\n\n  constructor(app: Mnote) {\n    this.app = app;\n\n    this.fs = (app.modules.fs as FSModule);\n\n    this.textarea = el(\"textarea\")\n      .class(\"plaintext-textarea\")\n      .class(\"mousetrap\") // enable shortcuts\n      .attr(\"spellcheck\", \"false\")\n      .element as HTMLTextAreaElement;\n\n    this.element = el(\"div\")\n      .class(\"plaintext-editor\")\n      .children(\n        this.textarea,\n      )\n      .element;\n  }\n\n  startup(containter: HTMLElement, ctx: EditorContext) {\n    this.textarea.addEventListener(\"input\", () => {\n      this.contents = this.textarea.value;\n      ctx.updateEdited();\n    });\n\n    this.container = containter;\n    containter.appendChild(this.element);\n  }\n\n  async load(path: string) {\n    const contents = await this.fs.readTextFile(path);\n    this.textarea.value = contents;\n  }\n\n  cleanup() {\n    this.container.removeChild(this.element);\n  }\n\n  async save(path: string) {\n    console.log(\"plaintext: save file\", path, this.contents);\n    await this.fs.writeTextFile(path, this.contents);\n  }\n}\n\n// provider\n\nclass PlaintextEditorProvider implements EditorProvider {\n  app: Mnote;\n\n  constructor(app: Mnote) {\n    this.app = app;\n  }\n\n  tryGetEditor(_path: string) {\n    // always return true, plaintext can open anything\n    return new PlaintextEditor(this.app);\n  }\n  createNewEditor() {\n    return new PlaintextEditor(this.app);\n  }\n}\n\n// extension\n\nexport class PlaintextExtension implements Extension {\n  app: Mnote;\n\n  constructor(app: Mnote) {\n    this.app = app;\n  }\n\n  startup() {\n    (this.app.modules.editors as EditorsModule).registerEditor({\n      kind: \"plaintext\",\n      provider: new PlaintextEditorProvider(this.app),\n    });\n  }\n\n  cleanup() {}\n}\n", "import { MenuItem, Mnote } from \"../common/types\";\nimport { EditorsModule } from \"../modules/editors\";\nimport {\n  DocInfo,\n  EditorContext,\n  EditorProvider,\n  Extension,\n} from \"../modules/types\";\nimport { Editor } from \"../modules/types\";\nimport { el } from \"../common/elbuilder\";\nimport { MenubarModule, SettingsModule } from \"../modules\";\n\n// an editor extension contains:\n// - the editor\n// - the provider\n// - the extension itself\n\n// instead of saving to file, the settings editor will\n// invoke the Settings.setSettings module\n\nclass SettingsEditor implements Editor {\n  app: Mnote;\n  element: HTMLElement;\n  textarea: HTMLTextAreaElement;\n  container?: HTMLElement;\n  settings: SettingsModule;\n\n  contents: string = \"\";\n\n  constructor(app: Mnote) {\n    this.app = app;\n    this.settings = (app.modules.settings as SettingsModule);\n    this.textarea = el(\"textarea\")\n      .class(\"plaintext-textarea\")\n      .class(\"mousetrap\") // enable shortcuts\n      .attr(\"spellcheck\", \"false\")\n      .element as HTMLTextAreaElement;\n\n    this.element = el(\"div\")\n      .class(\"plaintext-editor\")\n      .children(\n        this.textarea,\n      )\n      .element;\n  }\n\n  startup(containter: HTMLElement, ctx: EditorContext) {\n    ctx.setDocument({\n      name: \"Settings\",\n      path: \"donotpromptsaveas\",\n      saved: true,\n    });\n\n    this.textarea.addEventListener(\"input\", () => {\n      this.contents = this.textarea.value;\n      ctx.updateEdited();\n    });\n\n    this.container = containter;\n    containter.appendChild(this.element);\n  }\n\n  async load(_path: string) {\n    this.textarea.value = JSON.stringify(\n      this.settings.getSettings(),\n      undefined,\n      2,\n    );\n  }\n\n  cleanup() {\n    this.container.removeChild(this.element);\n  }\n\n  async save(path: string) {\n    const parsed = JSON.parse(this.contents);\n    if (!this.settings.isValidSettings(parsed)) {\n      // throw when error so the editor module\n      // can catch it with a modal\n      throw new Error(\"invalid settings\");\n    }\n\n    await this.settings.setSettings(parsed);\n  }\n}\n\n// provider\n\nclass SettingsEditorProvider implements EditorProvider {\n  app: Mnote;\n  settings: SettingsModule;\n\n  constructor(app: Mnote) {\n    this.app = app;\n    this.settings = app.modules.settings as SettingsModule;\n  }\n\n  tryGetEditor(_path: string) {}\n\n  createNewEditor() {\n    return new SettingsEditor(this.app);\n  }\n}\n\n// extension\n\nexport class SettingsExtension implements Extension {\n  app: Mnote;\n\n  constructor(app: Mnote) {\n    this.app = app;\n  }\n\n  startup() {\n    const openSettings = () => {\n      (this.app.modules.editors as EditorsModule).newEditor(\"Settings\");\n    };\n\n    (this.app.modules.menubar as MenubarModule).addSectionReducer(() => {\n      const button: MenuItem = {\n        name: \"Settings\",\n        click: openSettings,\n      };\n\n      return [button];\n    });\n\n    (this.app.modules.editors as EditorsModule).registerEditor({\n      kind: \"Settings\",\n      provider: new SettingsEditorProvider(this.app),\n      hideFromNewMenu: true,\n    });\n  }\n\n  cleanup() {}\n}\n", "// The implementation of the Mnote type in ./types\n\nimport { Mnote as Type, MnoteOptions, Module } from \"./common/types\";\n\nimport {\n  CtxmenuModule,\n  EditorsModule,\n  ExtensionsModule,\n  FiletreeModule,\n  FSModule,\n  InputModule,\n  LayoutModule,\n  LoggingModule,\n  MenubarModule,\n  SettingsModule,\n  SidemenuModule,\n  SystemModule,\n  ThemesModule,\n} from \"./modules\";\n\nimport { PlaintextExtension } from \"./extensions/plaintextEditor\";\nimport { SettingsExtension } from \"./extensions/settingsEditor\";\n\nimport { el } from \"./common/elbuilder\";\nimport { Modal } from \"./components/modal\";\nimport { ModalButton } from \"./modules/types\";\nimport { getPathParent } from \"./common/util/path\";\nimport { strings } from \"./common/strings\";\n\nexport class Mnote implements Type {\n  options: MnoteOptions;\n\n  element: Element;\n\n  directory: string;\n\n  modules: Record<string, Module> = {};\n\n  constructor(selector: string, options: MnoteOptions) {\n    this.options = options;\n\n    const element = document.querySelector(selector);\n    if (!element) {\n      throw new Error(`No element with selector \"${selector}\"!`);\n    }\n\n    this.element = el(\"div\")\n      .class(\"mnote\")\n      .parent(element)\n      .element;\n  }\n\n  async startup() {\n    // setup the interop modules\n    const fs = new FSModule(this.options.fs);\n    const system = new SystemModule(this.options.system);\n\n    // initialize with the startpath option\n    const startPath = this.options.startPath;\n    let startFile: string | undefined;\n\n    if (startPath) {\n      if (await fs.isDir(startPath)) {\n        this.directory = startPath;\n      } else if (await fs.isFile(startPath)) {\n        startFile = startPath;\n        const dir = getPathParent(startPath);\n        this.directory = dir;\n      } else {\n        this.directory = await fs.getCurrentDir();\n        const button: ModalButton = {\n          text: \"OK\",\n          command: \"\",\n          kind: \"emphasis\",\n        };\n        new Modal({\n          container: this.element,\n          message: strings.noStartPath(startPath),\n          buttons: [button],\n        }).prompt();\n      }\n    } else {\n      this.directory = await fs.getCurrentDir();\n    }\n\n    // initialize the watcher\n\n    fs.watchInit(this.directory);\n\n    // register the modules\n    this\n      .addModule(\"logging\", new LoggingModule(this))\n      .addModule(\"fs\", fs)\n      .addModule(\"system\", system)\n      .addModule(\"input\", new InputModule(this))\n      .addModule(\"extensions\", new ExtensionsModule(this))\n      .addModule(\"settings\", await new SettingsModule(this).init())\n      .addModule(\"layout\", new LayoutModule(this))\n      .addModule(\"ctxmenu\", new CtxmenuModule(this))\n      .addModule(\"sidemenu\", new SidemenuModule(this))\n      .addModule(\"filetree\", new FiletreeModule(this, startFile))\n      .addModule(\"menubar\", new MenubarModule(this))\n      .addModule(\"editors\", new EditorsModule(this))\n      .addModule(\"themes\", await new ThemesModule(this).init());\n\n    // register the extensions\n    (this.modules.extensions as ExtensionsModule)\n      .add(new PlaintextExtension(this))\n      .add(new SettingsExtension(this));\n  }\n\n  addModule(name: string, module: Module): Mnote {\n    this.modules[name] = module;\n    return this;\n  }\n}\n", "import { FileItemWithChildren, FsInteropModule } from \"../../mnote\";\n\nexport class FS implements FsInteropModule {\n  writeTextFile(path: string, contents: string): Promise<void> {\n    return Promise.resolve();\n  }\n  readTextFile(path: string): Promise<string> {\n    return Promise.resolve(\"lorem ipsum\");\n  }\n  readDir(path: string): Promise<FileItemWithChildren> {\n    const tree = {\n      path: \"dir-a\",\n      children: [\n        { path: \"file-b\" },\n        { path: \"file-c\" },\n        {\n          path: \"dir-d\",\n          children: [\n            { path: \"file-e\" },\n            { path: \"file-f\" },\n          ],\n        },\n      ],\n    } as FileItemWithChildren;\n\n    return Promise.resolve(tree);\n  }\n  isFile(path: string): Promise<boolean> {\n    return Promise.resolve(true);\n  }\n  isDir(path: string): Promise<boolean> {\n    return Promise.resolve(true);\n  }\n  dialogOpen(opts: {\n    initialPath?: string;\n    extensions?: string[];\n    directory: boolean;\n  }): Promise<string | void> {\n    return Promise.resolve(\"\");\n  }\n  dialogOpenMultiple(opts: {\n    initialPath?: string;\n    extensions?: string[];\n    directory: boolean;\n  }): Promise<string[] | void> {\n    return Promise.resolve([]);\n  }\n  dialogSave(opts: {\n    initialPath?: string;\n    extensions?: string[];\n  }): Promise<string | void> {\n    return Promise.resolve(\"\");\n  }\n  getConfigDir(): Promise<string> {\n    return Promise.resolve(\"configdir\");\n  }\n  getCurrentDir(): Promise<string> {\n    return Promise.resolve(\"currentdir\");\n  }\n  joinPath(items: string[]): string {\n    return items.join(\"/\");\n  }\n\n  watchInit(path: string): Promise<void> {\n    return Promise.resolve();\n  }\n\n  onWatchEvent(handler: () => void | Promise<void>): void {}\n}\n", "import { Mnote } from \"mnote-core\";\nimport { FS } from \"./fs\";\nimport \"../styles.scss\";\n\n// web build\n// for quick visual debugging\n\n(async () => {\n  const app = new Mnote(\"#root\", {\n    startPath: \"startpath\",\n    fs: new FS(),\n  });\n\n  await app.startup();\n})();\n"],
  "mappings": "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",
  "names": []
}
